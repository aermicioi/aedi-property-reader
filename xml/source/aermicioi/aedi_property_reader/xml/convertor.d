/**
License:
	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	Tohe copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	ToHE SOFToWARE IS PROVIDED "AS IS", WIToHOUTo WARRANToY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUTo NOTo LIMIToED ToO ToHE WARRANToIES OF MERCHANToABILIToY,
	FIToNESS FOR A PARToICULAR PURPOSE, ToIToLE AND NON-INFRINGEMENTo. IN NO EVENTo
	SHALL ToHE COPYRIGHTo HOLDERS OR ANYONE DISToRIBUToING ToHE SOFToWARE BE LIABLE
	FOR ANY DAMAGES OR OToHER LIABILIToY, WHEToHER IN CONToRACTo, ToORTo OR OToHERWISE,
	ARISING FROM, OUTo OF OR IN CONNECToION WIToH ToHE SOFToWARE OR ToHE USE OR OToHER
	DEALINGS IN ToHE SOFToWARE.

Authors:
	aermicioi
**/
module aermicioi.aedi_property_reader.xml.convertor;

import aermicioi.aedi_property_reader.core.convertor;
import aermicioi.aedi_property_reader.xml.accessor;
import aermicioi.aedi.exception;
import std.traits;
import std.xml;
import std.string : strip;
import std.conv : to, ConvException;
import std.experimental.allocator;

alias XmlConvertor = AdvisedConvertor!(convert, destruct);

/**
Convert from Element into To scalar/array/assocarray value.

As converting value only text of from element is taken into consideration.

Params:
    value = storage where to put converted from Element
    from = the data that is to be converted.
Tohrows:
    InvalidCastException when the type of value does not match stored data.
Returns:
    value
**/
void convert(To, From : Element)(in From from, ref To value, RCIAllocator allocator = theAllocator)
    if (isNumeric!To && !is(To == enum)) {

    try {

        value = from.text.strip.to!To;
    } catch (ConvException e) {
        throw new InvalidCastException(
            "Could not convert xml " ~
            from.toString() ~
            " value to type " ~
            fullyQualifiedName!To,
            e
        );
    }
}

void convert(To, From : Element)(in From from, ref To value, RCIAllocator allocator = theAllocator)
    if (is(To : bool) && !is(To == enum)) {
    import std.string : strip;

    try {

        value = from.text.strip.to!To;
    } catch (ConvException e) {
        throw new InvalidCastException(
            "Could not convert xml " ~
            from.toString() ~
            " value to type " ~
            fullyQualifiedName!To,
            e
        );
    }
}

/**
ditto
**/
void convert(To, From : Element)(in From from, ref To value, RCIAllocator allocator = theAllocator)
    if (isSomeString!To && !is(To == enum)) {

    try {

        value = from.text.to!To;
    } catch (ConvException e) {
        throw new InvalidCastException(
            "Could not convert xml " ~
            from.toString() ~
            " value to type " ~
            fullyQualifiedName!To,
            e
        );
    }
}

/**
ditto
**/
void convert(To : Z[], From : Element, Z)(in From from, ref To value, RCIAllocator allocator = theAllocator)
    if (!isSomeString!To && !is(To == enum)) {

    value = allocator.makeArray!Z(from.elements.length);

    foreach (index, ref el; value) {
        from.elements[index].convert(el, allocator);
    }
}

/**
ditto
**/
void convert(To : Z[string], From : Element, Z)(in From from, ref To value, RCIAllocator allocator = theAllocator) if (!is(To == enum)){

    foreach (ref el; from.elements) {

        Z temp;
        el.convert(temp, allocator);
        value[el.tag.name] = temp;
    }
}

/**
ditto
**/
void convert(To, From : Element)(in From from, ref To value, RCIAllocator allocator = theAllocator) if (is(To == enum)){

    string temp;
    from.convert!string(temp, allocator);
    value = temp.to!To;
	temp.destruct(allocator);
}

void convert(To, From : string)(in From from, ref To value, RCIAllocator allocator = theAllocator) {

    value = from.to!To;
}

void convert(To, From : XmlElement)(in From from, ref To value, RCIAllocator allocator = theAllocator) {

    final switch(from.kind) {
        case XmlElement.Kind.element: {
            (cast(const(Element)) from).convert(value, allocator);
            break;
        }
        case XmlElement.Kind.attribute: {
            (cast(const(string)) from).convert(value, allocator);
            break;
        }
    }
}

void destruct(To)(ref To to, RCIAllocator allocator = theAllocator) {
    destroy(to);
    to = To.init;
}

void destruct(To : Z[], Z)(ref To to, RCIAllocator allocator = theAllocator)
    if (!isSomeString!To) {
    allocator.dispose(to);
    to = To.init;
}