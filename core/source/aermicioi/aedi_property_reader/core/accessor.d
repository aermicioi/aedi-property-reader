/**
License:
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
    Alexandru Ermicioi
**/
module aermicioi.aedi_property_reader.core.accessor;

import aermicioi.aedi.storage.allocator_aware;
import taggedalgebraic;
import std.array;
import std.conv;
import aermicioi.aedi.exception.not_found_exception;
import aermicioi.aedi.exception.invalid_cast_exception;
import std.algorithm;
import std.range;
import std.exception : enforce;
import aermicioi.aedi_property_reader.core.exception;
import std.variant;
import std.traits;
import std.meta;
import aermicioi.util.traits;

interface PropertyAccessor(ComponentType, FieldType = ComponentType, KeyType = string) {

    FieldType access(ComponentType component, in KeyType property) const;

    bool has(in ComponentType component, in KeyType property) const;

    TypeInfo componentType(ComponentType component) const;
    TypeInfo fieldType(ComponentType component, in KeyType property) const;
}

interface AllocatingPropertyAccessor(ComponentType, FieldType = ComponentType, KeyType = string) :
    PropertyAccessor!(ComponentType, FieldType, KeyType),
    AllocatorAware!() {

}

class AggregatePropertyAccessor(ComponentType, FieldType = ComponentType, KeyType = string) : PropertyAccessor!(ComponentType, FieldType, KeyType) {

    private {

        PropertyAccessor!(ComponentType, FieldType)[] accessors_;
    }

    public {

        this(PropertyAccessor!(ComponentType, FieldType)[] accessors...) {
            this.accessors = accessors.dup;
        }

        /**
        Set accessors

        Params:
            accessors = accessors that implement various logic of accessing a property out of component

        Returns:
            typeof(this)
        **/
        typeof(this) accessors(PropertyAccessor!(ComponentType, FieldType, KeyType)[] accessors) @safe nothrow pure {
            this.accessors_ = accessors;

            return this;
        }

        /**
        ditto
        **/
        typeof(this) accessors(PropertyAccessor!(ComponentType, FieldType, KeyType)[] accessors...) @safe nothrow pure {
            this.accessors_ = accessors;

            return this;
        }

        /**
        Get accessors

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)[]) accessors() @safe nothrow pure inout {
            return this.accessors_;
        }

        FieldType access(ComponentType component, in KeyType property) const {

            foreach (accessor; this.accessors) {

                if (accessor.has(component, property)) {

                    return accessor.access(component, property);
                }
            }

            import aermicioi.aedi.exception.not_found_exception : NotFoundException;
            throw new NotFoundException("Could not find element");
        }

        bool has(in ComponentType component, in KeyType property) const {

            foreach (accessor; this.accessors) {

                if (accessor.has(component, property)) {
                    return true;
                }
            }

            return false;
        }

        TypeInfo componentType(ComponentType component) const {
            return typeid(ComponentType);
        }

        TypeInfo fieldType(ComponentType component, in KeyType property) const {
            return typeid(FieldType);
        }
    }
}

class PropertyPathAccessor(ComponentType, FieldType = ComponentType, KeyType = string) : PropertyAccessor!(ComponentType, FieldType, KeyType)
    if (isImplicitlyConvertible!(FieldType, ComponentType) && isInputRange!KeyType) {

    private {
        PropertyAccessor!(ComponentType, FieldType) accessor_;

        ElementType!KeyType separator_;
    }

    public {

        this(
            ElementType!KeyType separator,
            PropertyAccessor!(ComponentType, FieldType) accessor
        ) {
            this.separator = separator;
            this.accessor = accessor;
        }

        /**
        Set accessor

        Params:
            accessor = accessor instance responsible for getting a property out of component

        Returns:
            typeof(this)
        **/
        typeof(this) accessor(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) @safe nothrow pure {
            this.accessor_ = accessor;

            return this;
        }

        /**
        Get accessor

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)) accessor() @safe nothrow pure inout {
            return this.accessor_;
        }

        /**
        Set propertyAccessor

        Params:
            propertyAccessor = property splitter used to cut up the property path into multiple points

        Returns:
            typeof(this)
        **/
        typeof(this) separator(ElementType!KeyType separator) @safe nothrow pure {
            this.separator_ = separator;

            return this;
        }

        /**
        Get propertyAccessor

        Returns:
            ElementType!KeyType
        **/
        inout(ElementType!KeyType) separator() @safe nothrow pure inout {
            return this.separator_;
        }

        FieldType access(ComponentType component, in KeyType path) const {
            import std.algorithm;
            import std.range;

            auto identities = path.splitter(this.separator);

            ComponentType current = component;

            foreach (identity; identities) {

                if (this.accessor.has(current, identity)) {

                    current = this.accessor.access(current, identity);
                } else {

                    throw new NotFoundException(text("Could not find ", identity, " in ", current, " for property path of ", path));
                }
            }

            return current;
        }

        bool has(in ComponentType component, in KeyType path) const {

            auto identities = path.splitter(this.separator);

            ComponentType current = cast(ComponentType) component;

            foreach (identity; identities) {
                if (!this.accessor.has(current, identity)) {
                    return false;
                }

                if (this.accessor.has(current, identity)) {
                    current = this.accessor.access(current, identity);
                }
            }

            return true;
        }

        TypeInfo componentType(ComponentType component) const {
            return this.accessor.componentType(component);
        }

        TypeInfo fieldType(ComponentType component, in KeyType property) const {
            return this.accessor.fieldType(component, property);
        }
    }
}

auto propertyPathAccessor(T : PropertyAccessor!(ComponentType, FieldType, KeyType), ComponentType, FieldType, KeyType)
    (ElementType!KeyType separator, T accessor) {
    return new PropertyPathAccessor!(ComponentType, FieldType, KeyType)(separator, accessor);
}

class ArrayIndexedPropertyAccessor(ComponentType, FieldType = ComponentType, KeyType = string) : PropertyAccessor!(ComponentType, FieldType, KeyType)
    if (isBidirectionalRange!KeyType) {

    private {
        alias EType = ElementType!KeyType;
        EType beggining_;
        EType ending_;

        PropertyAccessor!(ComponentType, FieldType, KeyType) accessor_;
        PropertyAccessor!(ComponentType, FieldType, KeyType) indexer_;
    }

    public {

        this(EType beggining, EType ending, PropertyAccessor!(ComponentType, FieldType, KeyType) accessor, PropertyAccessor!(ComponentType, FieldType, KeyType) indexer) {
            this.beggining = beggining;
            this.ending = ending;
            this.accessor = accessor;
            this.indexer = indexer;
        }

        /**
        Set beggining

        Params:
            beggining = element denoting beggining of array syntax in identity, ex. [

        Returns:
            typeof(this)
        **/
        typeof(this) beggining(EType beggining) @safe nothrow pure {
            this.beggining_ = beggining;

            return this;
        }

        /**
        Get beggining

        Returns:
            EType
        **/
        inout(EType) beggining() @safe nothrow pure inout {
            return this.beggining_;
        }

        /**
        Set ending

        Params:
            ending = element denoting the end of array indexing, ex. ]

        Returns:
            typeof(this)
        **/
        typeof(this) ending(EType ending) @safe nothrow pure {
            this.ending_ = ending;

            return this;
        }

        /**
        Get ending

        Returns:
            EType
        **/
        inout(EType) ending() @safe nothrow pure inout {
            return this.ending_;
        }

        /**
        Set accessor

        Params:
            accessor = accessor used to access property part from indexed property

        Returns:
            typeof(this)
        **/
        typeof(this) accessor(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) @safe nothrow pure {
            this.accessor_ = accessor;

            return this;
        }

        /**
        Get accessor

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)) accessor() @safe nothrow pure inout {
            return this.accessor_;
        }

        /**
        Set indexer

        Params:
            indexer = property accessor used to access element based on contents in index part of property

        Returns:
            typeof(this)
        **/
        typeof(this) indexer(PropertyAccessor!(ComponentType, FieldType, KeyType) indexer) @safe nothrow pure {
            this.indexer_ = indexer;

            return this;
        }

        /**
        Get indexer

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)) indexer() @safe nothrow pure inout {
            return this.indexer_;
        }

        FieldType access(ComponentType component, in KeyType path) const {
            enforce!NotFoundException(this.has(component, path), text("Property ", path, " not found in ", component));

            auto splitted = path.splitter(this.beggining);
            enforce!InvalidArgumentException(!splitted.empty && !splitted.front.empty, text("Malformed indexed property ", path, ", no property part found"));

            FieldType property = this.accessor.access(component, splitted.front);
            splitted.popFront;
            enforce!InvalidArgumentException(!splitted.empty, text("Malformed indexed property ", path, ", no index part found"));

            foreach (identity; splitted) {
                enforce!InvalidArgumentException(identity.endsWith(this.ending), text("Malformed indexed property ", path, ", no closing ] found"));

                property = this.indexer.access(property, identity.dropBack(1));
            }

            return property;
        }

        bool has(in ComponentType component, in KeyType path) const {

            auto splitted = path.splitter(this.beggining);

            if (splitted.empty) {
                return false;
            }

            if (splitted.front.empty) {
                return false;
            }

            if (!this.accessor.has(component, splitted.front)) {
                return false;
            }

            FieldType property = this.accessor.access(cast(ComponentType) component, splitted.front);
            splitted.popFront;
            if (splitted.empty) {
                return false;
            }

            foreach (identity; splitted) {
                if (!identity.endsWith(this.ending)) {
                    return false;
                }

                if (!this.indexer.has(property, identity.dropBack(1))) {
                    return false;
                }

                property = this.indexer.access(property, identity.dropBack(1));
            }

            return true;
        }

        TypeInfo componentType(ComponentType component) const {
            return typeid(ComponentType);
        }

        TypeInfo fieldType(ComponentType component, in KeyType property) const {
            return typeid(FieldType);
        }
    }
}

auto arrayIndexedPropertyAccessor(T : PropertyAccessor!(ComponentType, FieldType, KeyType), ComponentType, FieldType, KeyType)
    (ElementType!KeyType beggining, ElementType!KeyType ending, T accessor, T indexer) {
    return new ArrayIndexedPropertyAccessor!(ComponentType, FieldType, KeyType)(beggining, ending, accessor, indexer);
}

class TickedPropertyAccessor(ComponentType, FieldType = ComponentType, KeyType = string) : PropertyAccessor!(ComponentType, FieldType, KeyType)
    if (isBidirectionalRange!KeyType) {

    private {
        alias EType = ElementType!KeyType;
        EType tick_;

        PropertyAccessor!(ComponentType, FieldType, KeyType) accessor_;
    }

    public {

        this(EType tick, PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) {
            this.tick = tick;
            this.accessor = accessor;
        }

        /**
        Set tick

        Params:
            tick = ticking element used to encapsulate property

        Returns:
            typeof(this)
        **/
        typeof(this) tick(EType tick) @safe nothrow pure {
            this.tick_ = tick;

            return this;
        }

        /**
        Get tick

        Returns:
            EType
        **/
        inout(EType) tick() @safe nothrow pure inout {
            return this.tick_;
        }

        /**
        Set accessor

        Params:
            accessor = accessor used to access property enclosed in ticks

        Returns:
            typeof(this)
        **/
        typeof(this) accessor(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) @safe nothrow pure {
            this.accessor_ = accessor;

            return this;
        }

        /**
        Get accessor

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)) accessor() @safe nothrow pure inout {
            return this.accessor_;
        }

        FieldType access(ComponentType component, in KeyType path) const {
            enforce!InvalidArgumentException(this.valid(path), text("Not found or malformed ticked property ", path));

            return this.accessor.access(component, path.drop(1).dropBack(1));
        }

        bool has(in ComponentType component, in KeyType path) const {

            return this.valid(path) && this.accessor.has(component, path.strip(this.tick));
        }

        TypeInfo componentType(ComponentType component) const {
            return this.accessor.componentType(component);
        }

        TypeInfo fieldType(ComponentType component, in KeyType property) const {
            return this.accessor.fieldType(component, property);
        }

        private bool valid(in KeyType path) const {
            return (path.front == this.tick) && (path.back == this.tick);
        }
    }
}

auto tickedAccessor(T : PropertyAccessor!(ComponentType, FieldType, KeyType), ComponentType, FieldType, KeyType)(ElementType!KeyType tick, T accessor) {
    return new TickedPropertyAccessor!(ComponentType, FieldType, KeyType)(tick, accessor);
}

class TaggedElementPropertyAccessorWrapper(Tagged : TaggedAlgebraic!Y, PropertyAccessorType : PropertyAccessor!(X, Z, KeyType), X, Z, KeyType = string, Y) : PropertyAccessor!(Tagged, Tagged, KeyType) {

    private {
        PropertyAccessorType accessor_;
    }

    public {
        this(PropertyAccessorType accessor) {
            this.accessor = accessor;
        }

        @property {
            /**
            Set accessor

            Params:
                accessor = the property accessor that is wrapped

            Returns:
                typeof(this)
            **/
            typeof(this) accessor(PropertyAccessorType accessor) @safe nothrow pure {
                this.accessor_ = accessor;

                return this;
            }

            /**
            Get accessor

            Returns:
                PropertyAccessorType
            **/
            inout(PropertyAccessorType) accessor() @safe nothrow pure inout {
                return this.accessor_;
            }
        }

        Tagged access(Tagged component, in KeyType property) const
        {
            if (this.has(component, property)) {
                return Tagged(this.accessor.access(cast(X) component, property));
            }

            import aermicioi.aedi.exception.not_found_exception : NotFoundException;
            import std.conv : text;
            throw new NotFoundException(text(component, " does not have ", property));
        }

        bool has(in Tagged component, in KeyType property) const {
            import std.meta;
            import aermicioi.util.traits;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Y." ~ e ~ ") : X)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return this.accessor.has(cast(const(X)) component, property);
                    }

                    return false;
                }
            }

            assert(false, "TaggedAlgebraic does not have " ~ fullyQualifiedName!X ~ " as member");
        }

        TypeInfo componentType(Tagged component) const {
            import std.meta;
            import aermicioi.util.traits;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Y." ~ e ~ ") : X)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return this.accessor.componentType(cast(X) component);
                    }
                }
            }

            assert(false, "Got stored a value that is not in tagged algebraic");
        }

        TypeInfo fieldType(Tagged component, in KeyType property) const {
            import std.meta;
            import aermicioi.util.traits;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Y." ~ e ~ ") : X)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return this.accessor.fieldType(cast(X) component, property);
                    }
                }
            }

            assert(false, "Got stored a value that is not in tagged algebraic");
        }
    }
}

auto taggedAccessor(Tagged, T : PropertyAccessor!(Composite, Field, Key), Composite, Field, Key)(T accessor) {
    return new TaggedElementPropertyAccessorWrapper!(Tagged, T)(accessor);
}

class AssociativeArrayAccessor(Type, Key = Type) : PropertyAccessor!(Type[Key], Type, Key) {

    public {

        Type access(Type[Key] component, in Key property) const {
            auto peek = property in component;
            enforce!NotFoundException(peek, text("Could not find ", property, " in associative array ", component));

            return *peek;
        }

        bool has(in Type[Key] component, in Key property) const {
            return (property in component) !is null;
        }

        TypeInfo componentType(Type[Key] component) const {
            return typeid(Type[Key]);
        }

        TypeInfo fieldType(Type[Key] component, in Key property) const {
            return typeid(Type);
        }
    }
}

class ArrayAccessor(Type) : PropertyAccessor!(Type[], Type, size_t) {

    public {

        Type access(Type[] component, in size_t property) const {
            enforce!NotFoundException(this.has(component, property), text("Could not find property ", property, " in array ", component));

            return component[property];
        }

        bool has(in Type[] component, in size_t property) const {
            return property < component.length;
        }

        TypeInfo componentType(Type[] component) const {
            return typeid(Type[]);
        }

        TypeInfo fieldType(Type[] component, in size_t property) const {
            return typeid(Type);
        }
    }
}

class VariantAccessor(
    ComponentType,
    FieldType = ComponentType,
    KeyType = ComponentType
) : PropertyAccessor!(ComponentType, FieldType, KeyType)
    if (
        is(ComponentType : VariantN!(ComponentSize, ComponentTypes), size_t ComponentSize, ComponentTypes...) &&
        is(FieldType : VariantN!(FieldSize, FieldTypes), size_t FieldSize, FieldTypes...) &&
        is(KeyType : VariantN!(KeySize, KeyTypes), size_t KeySize, KeyTypes...)
    ) {

    private {
        static if (is(ComponentType : VariantN!(ComponentSize, CTypes), size_t ComponentSize, CTypes...)) {
            alias ComponentTypes = CTypes;
        }

        static if (is(FieldType : VariantN!(FieldSize, FTypes), size_t FieldSize, FTypes...)) {
            alias FieldTypes = FTypes;
        }

        static if (is(KeyType : VariantN!(KeySize, KTypes), size_t KeySize, KTypes...)) {
            alias KeyTypes = KTypes;
        }
    }

    public {
        static foreach (KType; KeyTypes) {
            FieldType access(ComponentType component, KType key) const {
                return this.access(component, KeyType(key));
            }

            bool has(ComponentType component, KType key) const {
                return this.has(component, KeyType(key));
            }
        }

        FieldType access(ComponentType component, in KeyType key) const {
            static foreach (Component; ComponentTypes) {{
                static if (
                    is(Component : X[W], X, W) &&
                    anySatisfy!(ApplyLeft!(isD, X), FieldTypes) &&
                    anySatisfy!(ApplyLeft!(isD, W), KeyTypes)
                ) {
                    if (
                        (component.type is typeid(Component)) &&
                        (key.type is typeid(W)) &&
                        this.has(component, key)
                    ) {
                        return FieldType(component.get!Component[key.get!W]);
                    }
                }

                static if (
                    is(Component : Y[], Y) &&
                    anySatisfy!(ApplyLeft!(isD, Y), FieldTypes) &&
                    anySatisfy!(ApplyLeft!(isD, size_t), KeyTypes)
                ) {
                    if (
                        (component.type is typeid(Component)) &&
                        (key.type is typeid(size_t)) &&
                        this.has(component, key)
                    ) {
                        return FieldType(component.get!Component[key.get!size_t]);
                    }
                }
            }}

            throw new NotFoundException(text("Could not find ", key, " in ", component));
        }

        bool has(in ComponentType component, in KeyType key) const {
            static foreach (Component; ComponentTypes) {{
                static if (
                    is(Component : X[W], X, W) &&
                    anySatisfy!(ApplyLeft!(isD, X), FieldTypes) &&
                    anySatisfy!(ApplyLeft!(isD, W), KeyTypes)
                ) {
                    if (
                        (component.type is typeid(Component)) &&
                        (key.type is typeid(W)) &&
                        ((key.get!W in component.get!Component) !is null)
                    ) {
                        return true;
                    }
                }

                static if (
                    is(Component : Y[], Y) &&
                    anySatisfy!(ApplyLeft!(isD, Y), FieldTypes) &&
                    anySatisfy!(ApplyLeft!(isD, size_t), KeyTypes)
                ) {
                    if (
                        (component.type is typeid(Component)) &&
                        (key.type is typeid(size_t)) &&
                        (key.get!size_t < component.get!Component.length)
                    ) {
                        return true;
                    }
                }
            }}

            return false;
        }

        TypeInfo componentType(ComponentType component) const {
            return typeid(ComponentType);
        }

        TypeInfo fieldType(ComponentType component, in KeyType property) const {
            return typeid(FieldType);
        }
    }
}

class RuntimeCompositeAccessor(ComponentType, FieldType = ComponentType, KeyType = string) : PropertyAccessor!(Object, FieldType, KeyType) {
    import aermicioi.aedi_property_reader.core.convertor : identify, unwrap;
    private {
        PropertyAccessor!(ComponentType, FieldType, KeyType) accessor_;
    }

    public {
        this(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) {
            this.accessor = accessor;
        }

        /**
        Set accessor

        Params:
            accessor = underlying accessor working on unwrapped element

        Returns:
            typeof(this)
        **/
        typeof(this) accessor(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) @safe nothrow pure {
            this.accessor_ = accessor;

            return this;
        }

        /**
        Get accessor

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)) accessor() @safe nothrow pure inout {
            return this.accessor_;
        }

        FieldType access(Object component, in KeyType path) const {
            enforce!NotFoundException(this.has(component, path), text("Could not find property ", path));

            return this.accessor.access(component.unwrap!ComponentType, path);
        }

        bool has(in Object component, in KeyType path) const {

            return (component !is null) && component.unwrap!ComponentType && this.accessor.has(component.unwrap!ComponentType, path);
        }

        TypeInfo componentType(Object component) const {
            TypeInfo type = component.identify;

            if (type is typeid(ComponentType)) {

                return this.accessor.componentType(component.unwrap!ComponentType);
            }

            return type;
        }

        TypeInfo fieldType(Object component, in KeyType property) const {
            return this.accessor.fieldType(component.unwrap!ComponentType, property);
        }
    }
}

class RuntimeFieldAccessor(ComponentType, FieldType = ComponentType, KeyType = string) : AllocatingPropertyAccessor!(ComponentType, Object, KeyType) {
    import aermicioi.aedi_property_reader.core.convertor : identify, unwrap;
    import std.experimental.allocator;

    mixin AllocatorAwareMixin!(typeof(this));

    private {
        PropertyAccessor!(ComponentType, FieldType, KeyType) accessor_;
    }

    public {
        this(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) {
            this.allocator = theAllocator;
            this.accessor = accessor;
        }

        /**
        Set accessor

        Params:
            accessor = underlying accessor working on unwrapped element

        Returns:
            typeof(this)
        **/
        typeof(this) accessor(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor) @safe nothrow pure {
            this.accessor_ = accessor;

            return this;
        }

        /**
        Get accessor

        Returns:
            PropertyAccessor!(ComponentType, FieldType, KeyType)
        **/
        inout(PropertyAccessor!(ComponentType, FieldType, KeyType)) accessor() @safe nothrow pure inout {
            return this.accessor_;
        }

        Object access(ComponentType component, in KeyType path) const {
            import aermicioi.aedi_property_reader.core.convertor : placeholder;
            enforce!NotFoundException(this.has(component, path), text("Could not find property ", path));

            return this.accessor.access(component, path).placeholder(cast() this.allocator);
        }

        bool has(in ComponentType component, in KeyType path) const {

            return this.accessor.has(component, path);
        }

        TypeInfo componentType(ComponentType component) const {
            return this.accessor.componentType(component);
        }

        TypeInfo fieldType(ComponentType component, in KeyType property) const {
            return this.accessor.fieldType(component, property);
        }
    }
}

class CompositeAccessor(Type) : AllocatingPropertyAccessor!(Type, Object, string) {
    import std.traits;
    import std.meta;
    import aermicioi.util.traits;
    import aermicioi.aedi_property_reader.core.convertor;

    mixin AllocatorAwareMixin!(typeof(this));

    public {
        this() {
            import std.experimental.allocator;

            this.allocator = theAllocator;
        }

        Object access(Type component, in string property) const {
            foreach (string member; __traits(allMembers, Type)) {

                static if (isPublic!(component, member)) {
                    if (member == property) {
                        static if (
                            isField!(Type, member) ||
                            (
                                isSomeFunction!(__traits(getMember, component, member)) &&
                                anySatisfy!(isPropertyGetter, __traits(getOverloads, component, member)))
                            ) {

                            return (__traits(getMember, component, member)).placeholder(cast() this.allocator);
                        }
                    }
                }
            }

            throw new NotFoundException(text(typeid(Type), " does not have ", property, " property"));
        }

        bool has(in Type component, in string property) const {

            foreach (string member; __traits(allMembers, Type)) {

                static if (isPublic!(component, member)) {
                    if (member == property) {
                        static if (
                            isField!(Type, member) ||
                            (
                                isSomeFunction!(__traits(getMember, component, member)) &&
                                anySatisfy!(isPropertyGetter, __traits(getOverloads, component, member)))
                            ) {

                            return true;
                        }
                    }
                }
            }

            return false;
        }

        TypeInfo componentType(Type component) const {
            return typeid(Type);
        }

        TypeInfo fieldType(Type component, in string property) const {
            foreach (string member; __traits(allMembers, Type)) {

                static if (isPublic!(component, member)) {
                    if (member == property) {
                        static if (
                            isField!(Type, member) ||
                            (
                                isSomeFunction!(__traits(getMember, component, member)) &&
                                anySatisfy!(isPropertyGetter, __traits(getOverloads, component, member)))
                            ) {

                            return typeid(typeof(__traits(getMember, component, member)));
                        }
                    }
                }
            }

            throw new NotFoundException(text(typeid(Type), " does not have ", property, " property"));
        }
    }
}

auto dsl(ComponentType, FieldType, KeyType)(PropertyAccessor!(ComponentType, FieldType, KeyType) accessor, PropertyAccessor!(ComponentType, FieldType, KeyType) indexer) {
    return new PropertyPathAccessor!(ComponentType, FieldType, KeyType)(
        '.',
        new AggregatePropertyAccessor!(ComponentType, FieldType, KeyType)(
            accessor,
            new ArrayIndexedPropertyAccessor!(ComponentType, FieldType, KeyType)(
                '[', ']',
                accessor,
                new AggregatePropertyAccessor!(ComponentType, FieldType, KeyType)(
                    new TickedPropertyAccessor!(ComponentType, FieldType, KeyType)(
                        '\'',
                        accessor,
                    ),
                    new TickedPropertyAccessor!(ComponentType, FieldType, KeyType)(
                        '"',
                        accessor,
                    ),
                    indexer
                )
            )
        )
    );
}

private {
    enum isD(T, X) = is(T : X);
}