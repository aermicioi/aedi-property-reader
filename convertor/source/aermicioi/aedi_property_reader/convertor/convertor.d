/**
License:
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
    Alexandru Ermicioi
**/
module aermicioi.aedi_property_reader.convertor.convertor;

import aermicioi.aedi;
import aermicioi.aedi_property_reader.convertor.exception : ConvertorException;
import aermicioi.aedi.storage.wrapper;
import std.meta;
import std.conv;
import std.experimental.allocator;
import std.exception : enforce;
import aermicioi.aedi_property_reader.convertor.accessor;
import aermicioi.aedi_property_reader.convertor.setter;
import aermicioi.aedi_property_reader.convertor.inspector;
import aermicioi.aedi_property_reader.convertor.traits;
import aermicioi.aedi_property_reader.convertor.placeholder;
import std.algorithm;
import std.array;
import std.traits;
import std.experimental.logger;
import taggedalgebraic : TaggedAlgebraic;

alias ScalarConvertibleTypes = AliasSeq!(
	ubyte, byte, ushort, short, uint, int, ulong, long, float, double, real, char, wchar, dchar
);

alias StringConvertibleTypes = AliasSeq!(
    string, wstring, dstring
);

alias ScalarArrayConvertibleTypes = AliasSeq!(
	ubyte[], byte[], ushort[], short[], uint[], int[], ulong[], long[], float[], double[], real[],
    char[], wchar[], dchar[], string[]
);

alias DefaultConvertibleTypes = AliasSeq!(
    ScalarConvertibleTypes, StringConvertibleTypes, ScalarArrayConvertibleTypes
);

/**
Functional convertor that is taking a component of type From and converts it into a component of type To.

Params:
    from = original component that is converted.
    to = destination component that is constructed.
    allocator = optional allocator used to allocate required memory during conversion.
**/
alias FunctionalConvertor(To, From) = void function(in From, ref To, RCIAllocator allocator = theAllocator);

/**
ditto
**/
alias DelegateConvertor(To, From) = void delegate(in From, ref To, RCIAllocator allocator = theAllocator);

/**
Check wether T symbol is a functional convertor.

Params:
    T = symbol to be tested.

Returns:
    Symbols: yes -> whether it is or not, From -> type of original component that function is accepting, To -> destination type that function is converting.
**/
template isConvertor(alias T)
    if (isSomeFunction!T) {
    static if (
        is(typeof(&T) : R function(in Y, ref X, RCIAllocator), Y, X, R) ||
        is(typeof(&T) : R delegate(in Y, ref X, RCIAllocator), Y, X, R) ||
        is(typeof(T) : R function(in Y, ref X, RCIAllocator), Y, X, R) ||
        is(typeof(T) : R delegate(in Y, ref X, RCIAllocator), Y, X, R)
    ) {
        enum bool yes = true;

        alias To = X;
        alias From = Y;
    } else {

        enum bool yes = false;
    }
}

/**
Check whether symbol T is a functional convertor from type From to type To.

Params:
    T = symbol to test
    To = destination type
    From = original type

Returns:
    yes -> whether it is or not,
    From -> type of original component that function is accepting,
    To -> destination type that function is converting.
**/
template isConvertor(alias T, To, From) {
    static if (isConvertor!T.yes && is(isConvertor!T.To == To) && is(isConvertor!T.From == From)) {
        alias isConvertor = isConvertor!T;
    } else {
        enum yes = false;
    }
}

/**
Test whether template T can be instantiated as a functional convertor from From to To.

Params:
    T = template that is to be instantiated
    To = destination type
    From = original type
Returns:
    yes -> whether it is possible to instantiate template as functional convertor
    Convertor -> resulting functional convertor
    Info -> data returned by isConvertor
**/
template maybeConvertor(alias T, To, From) {
    static if (is(typeof(isConvertor!(T!(To, From)))) && isConvertor!(T!(To, From)).yes) {
        enum yes = true;
        alias Convertor = T!(To, From);
        alias Info = isConvertor!Convertor;
    } else {
        enum yes = false;
    }
}

/**
Functional destructor responsible for destroying components of To type.

Params:
    to = the component that is to be destroyed.
    allocator = the allocator originally used to allocate all memory for To component
**/
alias FunctionalDestructor(To) = void function (ref To, RCIAllocator = theAllocator);

/**
ditto
**/
alias DelegateDestructor(To) = void delegate (ref To, RCIAllocator = theAllocator);

/**
Check whether symbol T is a functional destructor.

Params:
    T = symbol to be tested.
Returns:
    yes = whether it is functional destructor or not
    To = the type of accepted components to be destructed
**/
template isDestructor(alias T) {
    static if (
        is(typeof(&T) : R function (ref X, RCIAllocator = theAllocator), X, R) ||
        is(typeof(&T) : R delegate (ref X, RCIAllocator = theAllocator), X, R) ||
        is(typeof(T) : R function (ref X, RCIAllocator = theAllocator), X, R) ||
        is(typeof(T) : R delegate (ref X, RCIAllocator = theAllocator), X, R)
    ) {
        enum bool yes = true;

        alias To = X;
    } else {

        enum bool yes = false;
    }
}

/**
Check if symbol T is a functional destructor for component of type To

Params:
    T = symbol that is tested
    To = the component that functional destructor may accept

Returns:
    yes = whether it is functional destructor or not
    To = the type of accepted components to be destructed
**/
template isDestructor(T, To) {
    static if (isDestructor!T.yes && is(isDestructor!T.To == To)) {
        alias isDestructor = isDestructor!T;
    } else {
        enum yes = false;
    }
}

/**
Test if T template's instantiantiation with type To is a functional destructor for component of type To.

Params:
    T = template that is to be tested.
    To = the type of component that T instantiation should manage destruction.

Returns:
    yes -> whether it is possible to instantiate a functional destructor for To or not
    Destructor -> the instantiated functional destructor
    Info -> information from isDestructor check
**/
template maybeDestructor(alias T, To) {
    static if (isDestructor!(T!To).yes) {
        enum yes = true;
        alias Destructor = T!(To);
        alias Info = isDestructor!Destructor;
    } else {
        enum yes = false;
    }
}

/**
Interface for components that are able to convert from one erased type to another erased type.
**/
interface Convertor {
    @property {

        /**
        Get the type info of component that convertor can convert from.

        Get the type info of component that convertor can convert from.
        The method is returning the default type that it is able to convert,
        though it is not necessarily limited to this type only. More generalistic
        checks should be done by convertsFrom method.

        Returns:
            type info of component that convertor is able to convert.
        **/
        TypeInfo from() @safe const nothrow pure;

        /**
        Get the type info of component that convertor is able to convert to.

        Get the type info of component that convertor is able to convert to.
        The method is returning the default type that is able to convert,
        though it is not necessarily limited to this type only. More generalistic
        checks should be done by convertsTo method.

        Returns:
            type info of component that can be converted to.
        **/
        TypeInfo to() @safe const nothrow pure;
    }

    /**
    Check whether convertor is able to convert from.

    Check whether convertor is able to convert from.
    The intent of method is to implement customized type checking
    is not limited immediatly to supported default from component.

    Params:
        from = the type info of component that could potentially be converted by convertor.
    Returns:
        true if it is able to convert from, or false otherwise.
    **/
    bool convertsFrom(TypeInfo from) @safe const nothrow pure ;

    /**
    Check whether convertor is able to convert from.

    Check whether convertor is able to convert from.
    The method will try to extract type info out of from
    object and use for subsequent type checking.
    The intent of method is to implement customized type checking
    is not limited immediatly to supported default from component.

    Params:
        from = the type info of component that could potentially be converted by convertor.
    Returns:
        true if it is able to convert from, or false otherwise.
    **/
    bool convertsFrom(in Object from) @safe const nothrow pure ;

    /**
    Check whether convertor is able to convert to.

    Check whether convertor is able to convert to.
    The intent of the method is to implement customized type checking
    that is not limited immediatly to supported default to component.

    Params:
        to = type info of component that convertor could potentially convert to.

    Returns:
        true if it is able to convert to, false otherwise.
    **/
    bool convertsTo(TypeInfo to) @safe const nothrow pure ;

    /**
    Check whether convertor is able to convert to.

    Check whether convertor is able to convert to.
    The method will try to extract type info out of to object and use
    for subsequent type checking.
    The intent of the method is to implement customized type checking
    that is not limited immediatly to supported default to component.

    Params:
        to = type info of component that convertor could potentially convert to.

    Returns:
        true if it is able to convert to, false otherwise.
    **/
    bool convertsTo(in Object to) @safe const nothrow pure ;

    /**
    Convert from component to component.

    Params:
        from = original component that is to be converted.
        to = destination object that will be constructed out for original one.
        allocator = optional allocator that could be used to construct to component.
    Throws:
        ConvertorException when there is a converting error
        InvalidArgumentException when arguments passed are not of right type or state
    Returns:
        Resulting converted component.
    **/
    Object convert(in Object from, TypeInfo to, RCIAllocator allocator = theAllocator) const;

    /**
    Destroy component created using this convertor.

    Destroy component created using this convertor.
    Since convertor could potentially allocate memory for
    converted component, only itself is containing history of allocation,
    and therefore it is responsible as well to destroy and free allocated
    memory with allocator.

    Params:
        converted = component that should be destroyed.
        allocator = allocator used to allocate converted component.
    **/
    void destruct(ref Object converted, RCIAllocator allocator = theAllocator) const;
}

/**
Mixin that provides default implementation of equality comparison for convertors
**/
mixin template EqualMixin() {

    override bool opEquals(Object o) {
        return super.opEquals(o) || ((this.classinfo is o.classinfo) && this.opEquals(cast(Convertor) o));
    }

    bool opEquals(Convertor convertor) {
        return (convertor !is null) && ((this.from is convertor.from) || (this.to is convertor.to));
    }
}

/**
Mixin that provides default implementation of hashing algorithm
**/
mixin template ToHashMixin() {

    override size_t toHash() {
        import std.digest.murmurhash : MurmurHash3;
        import std.digest : digest;

        size_t[8] buffer;
        buffer[0] = this.from.toHash;
        buffer[1] = this.to.toHash;
        buffer[2] = this.classinfo.toHash;

        return cast(size_t) *(&digest!(MurmurHash3!128)(buffer[])[0]);
    }
}

/**
Mixin that provides default implementation of toString method
**/
mixin template ToStringMixin() {

    override string toString() {
        import std.conv : text;
        import std.algorithm : until;
        import std.range : retro;
        return text(
            typeid(this).name.retro.until('.').array.retro,
            " [", this.from, ", ", this.to, "]"
        );
    }
}

/**
Default implementation of comparison between two or more convertors.
**/
mixin template OpCmpMixin() {

    override int opCmp(Object o) const {

        auto result = cast(int)cast(void*)this - cast(int)cast(void*)o;

        if (result == 0) {
            result =
                this.classinfo.name < o.classinfo.name ? -1 :
                (this.classinfo.name > o.classinfo.name ? 1 : 0);
        }

        return result;
    }
}

/**
Amalgation of EqualMixin, ToHashMixin, ToStringMixin, and OpCmpMixin
**/
mixin template EqualToHashToStringOpCmpMixin() {
    mixin EqualMixin!();
    mixin ToHashMixin!();
    mixin ToStringMixin!();
    mixin OpCmpMixin!();
}

/**
A convertor that is using functional convertor and destructor for conversion logic.
**/
class CallbackConvertor(alias convertor, alias destructor) : Convertor
    if (isConvertor!convertor.yes && isDestructor!destructor.yes) {

    private {
        alias Info = isConvertor!convertor;
    }

    public {

        @property {
            /**
            Get the type info of component that convertor can convert from.

            Get the type info of component that convertor can convert from.
            The method is returning the default type that it is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsFrom method.

            Returns:
                type info of component that convertor is able to convert.
            **/
            TypeInfo from() @safe nothrow pure const {
                return typeid(Info.From);
            }

            /**
            Get the type info of component that convertor is able to convert to.

            Get the type info of component that convertor is able to convert to.
            The method is returning the default type that is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsTo method.

            Returns:
                type info of component that can be converted to.
            **/
            TypeInfo to() @safe nothrow pure const {
                return typeid(Info.To);
            }
        }

        /**
        Check whether convertor is able to convert from.

        Params:
            from = the type info of component that could potentially be converted by convertor.
        Returns:
            true if it is able to convert from, or false otherwise.
        **/
        bool convertsFrom(TypeInfo from) @safe const nothrow pure {
            return typeid(Info.From) is from;
        }

        /**
        ditto
        **/
        bool convertsFrom(in Object from) @safe const nothrow pure {
            return this.convertsFrom(from.identify);
        }

        /**
        Check whether convertor is able to convert to.

        Params:
            to = type info of component that convertor could potentially convert to.

        Returns:
            true if it is able to convert to, false otherwise.
        **/
        bool convertsTo(TypeInfo to) @safe const nothrow pure {
            return typeid(Info.To) is to;
        }

        /**
        ditto
        **/
        bool convertsTo(in Object to) @safe const nothrow pure {
            return this.convertsTo(to.identify);
        }

        /**
        Convert from component to component.

        Convert from component to component.
        In case when functional convertor's from argument is rooted in Object
        class, the convertor will attempt to downcast passed component to
        it's rightfull type. If not, the convertor will attempt to downcast
        from component to placeholding object of value that is accepted by functional
        convertor.
        For converted to component, in case when it is rooted in Object class
        nothing special is performed, while otherwise it will be wrapped into placeholding
        object allocated by allocator that will be returned to callee.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, TypeInfo to, RCIAllocator allocator = theAllocator) const
        {
            enforce!ConvertorException(
                this.convertsTo(to),
                text(to, " is not supported destination by convertor expected ", typeid(Info.To))
            );
            enforce!ConvertorException(
                this.convertsFrom(from),
                text(from.identify, " is not supported source by convertor expected ", typeid(Info.From))
            );

            static if (is(From : Object)) {
                Info.From naked = cast(From) from;

                if (naked is null) {
                    throw new ConvertorException(
                        text("Cannot convert ", from.classinfo, " only supported ", this.from)
                    );
                }
            } else {

                auto wrapper = (cast(Placeholder!(Info.From)) from);

                if (wrapper is null) {
                    throw new ConvertorException(text("Cannot convert ", from.identify, " only supported ", this.from));
                }

                Info.From naked = wrapper.value;
            }


            static if (is(Info.To : Object)) {
                Info.To placeholder = allocator.make!(Info.To);

                convertor(naked, placeholder, allocator);
            } else {
                PlaceholderImpl!(Info.To) placeholder = allocator.make!(PlaceholderImpl!(Info.To))(Info.To.init);

                convertor(naked, placeholder.value, allocator);
            }

            return placeholder;
        }

        /**
        Destroy component created using this convertor.

        Destroy component created using this convertor.
        The method will attempt to downcast converted component
        to type supported by functional destructor when the type is rooted in
        Object class, otherwise it will attempt to downcast converted to placeholding
        object of value supported by functional destructor. In latest case, the
        method will dispose out of placeholding object using passed allocator.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(ref Object converted, RCIAllocator allocator = theAllocator) const {
            static if (is(Info.To : Object)) {

                auto c = cast(Info.To) converted;
                destructor(c, allocator);

                converted = null;
            } else {
                auto container = cast(Placeholder!(Info.To)) converted;

                destructor(container.value, allocator);
                allocator.dispose(converted);
            }
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that is providing additional type information for converted tagged types.

A convertor that is providing additional type information for converted tagged types.
In case when wrong convertor is passed to tagged convertor, any type conversion
and information capabilities are inhibited.
**/
class TaggedConvertor(Tagged : TaggedAlgebraic!Union, Union) : Convertor {

    private {
        Convertor convertor_;
    }

    public {

        /**
        Constructor for TaggedConvertor

        Params:
            convertor = convertor for underlying tagged types
        **/
        this(Convertor convertor) {
            this.convertor = convertor;
        }

        @property {
            /**
            Set convertor

            Params:
                convertor = convertor accepting a tagged union that will be decorated with addional type information.

            Returns:
                typeof(this)
            **/
            typeof(this) convertor(Convertor convertor) @safe nothrow pure {
                this.convertor_ = convertor;

                return this;
            }

            /**
            Get convertor

            Returns:
                Convertor
            **/
            inout(Convertor) convertor() @safe nothrow pure inout {
                return this.convertor_;
            }

            /**
            Get the type info of component that convertor can convert from.

            Get the type info of component that convertor can convert from.
            The method is returning the default type that it is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsFrom method.

            Returns:
                type info of component that convertor is able to convert.
            **/
            TypeInfo from() nothrow const {
                return this.convertor.from is typeid(Tagged) ? typeid(Tagged) : typeid(void);
            }

            /**
            Get the type info of component that convertor is able to convert to.

            Get the type info of component that convertor is able to convert to.
            The method is returning the default type that is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsTo method.

            Returns:
                type info of component that can be converted to.
            **/
            TypeInfo to() nothrow const {
                return this.convertor.to;
            }
        }

        /**
        Check whether convertor is able to convert from.

        Params:
            from = the type info of component that could potentially be converted by convertor.
        Returns:
            true if it is able to convert from, or false otherwise.
        **/
        bool convertsFrom(TypeInfo from) @safe const nothrow pure  {
            if (from is typeid(void)) {
                return false;
            }

            if (this.convertor.convertsFrom(from)) {
                return true;
            }

            static foreach (T; Fields!Union) {
                if (from is typeid(T)) {
                    return true;
                }
            }

            return false;
        }

        /**
        ditto
        **/
        bool convertsFrom(in Object from) @safe const nothrow pure  {
            return this.convertsFrom(from.identify);
        }

        /**
        Check whether convertor is able to convert to.

        Params:
            to = type info of component that convertor could potentially convert to.

        Returns:
            true if it is able to convert to, false otherwise.
        **/
        bool convertsTo(TypeInfo to) @safe const nothrow pure  {
            return this.convertor.convertsTo(to);
        }

        /**
        ditto
        **/
        bool convertsTo(in Object to) @safe const nothrow pure  {
            return this.convertsTo(to.identify);
        }

        /**
        Convert from component to component.

        Convert from component to component.
        In case when functional convertor's from argument is rooted in Object
        class, the convertor will attempt to downcast passed component to
        it's rightfull type. If not, the convertor will attempt to downcast
        from component to placeholding object of value that is accepted by functional
        convertor.
        For converted to component, in case when it is rooted in Object class
        nothing special is performed, while otherwise it will be wrapped into placeholding
        object allocated by allocator that will be returned to callee.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, TypeInfo to, RCIAllocator allocator = theAllocator) const
        {
            return this.convertor.convert(from, to, allocator);
        }

        /**
        Destroy component created using this convertor.

        Destroy component created using this convertor.
        The method will attempt to downcast converted component
        to type supported by functional destructor when the type is rooted in
        Object class, otherwise it will attempt to downcast converted to placeholding
        object of value supported by functional destructor. In latest case, the
        method will dispose out of placeholding object using passed allocator.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(ref Object converted, RCIAllocator allocator = theAllocator) const {
            return this.convertor.destruct(converted, allocator);
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
Interface for convertors that could rely on another convertors to convert a value.
**/
interface CombinedConvertor : Convertor {

    /**
    Set used convertors

    Params:
        convertors = list of convertors to be used.

    Returns:
        typeof(this)
    **/
    typeof(this) convertors(Convertor[] convertors) @safe nothrow;

    /**
    ditto
    **/
    T convertors(this T)(Convertor convertors...) @safe nothrow {
        return this.convertors(convertors.dup);
    }

    /**
    Add a convertor to existing list

    Params:
        convertor = convertor to be added to

    Returns:
        typeof(this)
    **/
    typeof(this) add(Convertor convertor) @safe nothrow;

    /**
    Remove a convertor from existing list

    Params:
        convertor = convertor to be removed

    Returns:
        typeof(this)
    **/
    typeof(this) remove(Convertor convertor) @safe nothrow;
}

/**
A convertor that is delegating converting task to a set of child convertors.
**/
class CombinedConvertorImpl : CombinedConvertor {
    import std.algorithm : canFind, find;

    private {
        Convertor[] convertors_;
    }

    public {

        /**
        Default constructor for AggregateConvertor
        **/
        @safe this(Convertor[] convertors...) {
            this.convertors = convertors.dup;
        }

        /**
        Set convertors

        Params:
            convertors = convertors used to convert from one type to another

        Returns:
            typeof(this)
        **/
        typeof(this) convertors(Convertor[] convertors) @safe nothrow pure {
            this.convertors_ = convertors;

            return this;
        }

        /**
        Get convertors

        Returns:
            Convertor[]
        **/
        inout(Convertor[]) convertors() @safe nothrow pure inout {
            return this.convertors_;
        }

        /**
        Add a convertor to existing list

        Params:
            convertor = convertor to be added to

        Returns:
            typeof(this)
        **/
        typeof(this) add(Convertor convertor) @safe {
            this.convertors_ ~= convertor;

            return this;
        }

        /**
        Remove a convertor from existing list

        Params:
            convertor = convertor to be removed

        Returns:
            typeof(this)
        **/
        typeof(this) remove(Convertor convertor) @trusted nothrow {
            import std.algorithm : remove, countUntil;
            import std.array : array;

            try {

                this.convertors_ = this.convertors_.remove(this.convertors.countUntil!(c => c == convertor));
            } catch (Exception e) {
                assert(false, text("countUntil threw an exception: ", e));
            }

            return this;
        }

        @property {
            /**
            Get the type info of component that convertor can convert from.

            Get the type info of component that convertor can convert from.
            The method is returning the default type that it is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsFrom method.

            Returns:
                type info of component that convertor is able to convert.
            **/
            TypeInfo from() @safe nothrow pure const {
                return typeid(void);
            }

            /**
            Get the type info of component that convertor is able to convert to.

            Get the type info of component that convertor is able to convert to.
            The method is returning the default type that is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsTo method.

            Returns:
                type info of component that can be converted to.
            **/
            TypeInfo to() @safe nothrow pure const {
                return typeid(void);
            }
        }

        /**
        Check whether convertor is able to convert from.

        Params:
            from = the type info of component that could potentially be converted by convertor.
        Returns:
            true if it is able to convert from, or false otherwise.
        **/
        bool convertsFrom(TypeInfo from) const {
            return this.convertors.canFind!(c => c.convertsFrom(from));
        }

        /**
        ditto
        **/
        bool convertsFrom(in Object from) const {
            return this.convertors.canFind!(c => c.convertsFrom(from));
        }

        /**
        Check whether convertor is able to convert to.

        Params:
            to = type info of component that convertor could potentially convert to.

        Returns:
            true if it is able to convert to, false otherwise.
        **/
        bool convertsTo(TypeInfo to) const {
            return this.convertors.canFind!(c => c.convertsTo(to));
        }

        /**
        ditto
        **/
        bool convertsTo(in Object to) const {
            return this.convertors.canFind!(c => c.convertsTo(to));
        }

        /**
        Convert from component to component.

        Finds a right convertor from component to component and uses it
        to execute conversion from component to component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, TypeInfo to, RCIAllocator allocator = theAllocator) const
        {
            auto convertors = this.convertors.find!(c => c.convertsFrom(from) && c.convertsTo(to));

            if (!convertors.empty) {
                return convertors[0].convert(from, to, allocator);
            }

            throw new ConvertorException(text("Could not convert ", typeid(from), " to type ", to));
        }

        /**
        Destroy component created using this convertor.

        Find a suitable convertor for destruction and use it to execute destruction.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(ref Object converted, RCIAllocator allocator = theAllocator) const {
            auto convertors = this.convertors.find!(c => c.convertsTo(converted));

            if (convertors.empty) {
                throw new ConvertorException(text("Could not destroy ", converted));
            }

            convertors[0].destruct(converted, allocator);
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that simply doesn't do any conversion and returns existing object
**/
class NoOpConvertor : Convertor {
    import std.algorithm;

    public {
        @property {
            /**
            Get the type info of component that convertor can convert from.

            Get the type info of component that convertor can convert from.
            The method is returning the default type that it is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsFrom method.

            Returns:
                type info of component that convertor is able to convert.
            **/
            TypeInfo from() @safe nothrow pure const {
                return typeid(Object);
            }

            /**
            Get the type info of component that convertor is able to convert to.

            Get the type info of component that convertor is able to convert to.
            The method is returning the default type that is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsTo method.

            Returns:
                type info of component that can be converted to.
            **/
            TypeInfo to() @safe nothrow pure const {
                return typeid(Object);
            }
        }

        /**
        Check whether convertor is able to convert from.

        Params:
            from = the type info of component that could potentially be converted by convertor.
        Returns:
            true if it is able to convert from, or false otherwise.
        **/
        bool convertsFrom(TypeInfo from) const {
            return this.from is from;
        }

        /**
        ditto
        **/
        bool convertsFrom(in Object from) const {
            return this.convertsTo(typeid(from));
        }

        /**
        Check whether convertor is able to convert to.

        Params:
            to = type info of component that convertor could potentially convert to.

        Returns:
            true if it is able to convert to, false otherwise.
        **/
        bool convertsTo(TypeInfo to) const {
            return this.to is to;
        }

        /**
        ditto
        **/
        bool convertsTo(in Object to) const {
            return this.convertsTo(typeid(to));
        }

        /**
        Convert from component to component.

        It will simply pass existing from component as to component
        as consequence requested to component should be same as type info
        of from component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, TypeInfo to, RCIAllocator allocator = theAllocator) const
        {
            enforce!ConvertorException(
                from.identify is to,
                text(
                    "Cannot do no op when expected ",
                    to,
                    " type is not of same type as original from ",
                    from.identify,
                    " type"
                )
            );

            return cast() from;
        }

        /**
        Does not destruct anything since it is not allocating anything.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(ref Object converted, RCIAllocator allocator = theAllocator) const {

        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
Convert from into component of type To using a convertor for this.

Params:
    convertor = the convertor used to convert from component into To
    from = original component that is to be converted
    allocator = optional allocator used to allocate memory for converted component

Returns:
    To converted component
**/
To convert(To, From)(Convertor convertor, From from, RCIAllocator allocator = theAllocator) {
    import std.typecons : scoped;
    static if (is(From : Object)) {

        Object converted = convertor.convert(from, typeid(To), allocator);
    } else {

        Object converted = convertor.convert(scoped!(PlaceholderImpl!From)(from), typeid(To), allocator);
    }

    static if (is(To : Object)) {

        return cast(To) converted;
    } else {

        scope(exit) allocator.dispose(converted);
        return (cast(Placeholder!To) converted).value;
    }
}

enum isConvertorBuilder(T) =
    hasMember!(T, "make") &&
    hasMember!(T, "isAble") &&
    hasMember!(T, "cause");

/**
A callback convertor factory advised with functional convertor and destructor.

Params:
    convertor = functional convertor used for callback convertor
    destructor = functional destructor used for callback convertor

Returns:
    AdvisedConvertor(To, From) template ready to instantiate a callback convertor for To, and From types using convertor and destructor.
**/
template CallbackConvertorBuilder(alias convertor, alias destructor) {
    class CallbackConvertorBuilder {
        bool throwOnFailure = true;

        this() {

        }

        this(bool throwOnFailure) {
            this.throwOnFailure = throwOnFailure;
        }

        Convertor make(To, From)() {
            static if (isAble!(To, From)) {

                return new CallbackConvertor!(convertor!(To, From), destructor!To);
            } else {

                if (this.throwOnFailure) {
                    throw new Exception(this.cause!(To, From));
                } else {
                    error(this.cause!(To, From));
                }

                return null;
            }
        }

        static bool isAble(To, From)() {
            return maybeConvertor!(convertor, To, From).yes && maybeDestructor!(destructor, To).yes;
        }

        static string cause(To, From)() {
            alias ConvertorInfo = maybeConvertor!(convertor, To, From);
            alias DestructorInfo = maybeDestructor!(destructor, To);
            return text(
                    "Cannot convert type ",
                    typeid(From),
                    " to ",
                    typeid(To),
                    " when:\n ",
                    fullyQualifiedName!convertor,
                    " implements convertor ",
                    ConvertorInfo.yes,
                    "\n ",
                    fullyQualifiedName!destructor,
                    " implements destructor ",
                    DestructorInfo.yes
                );
        }
    }
}

/**
A composite convertor factory advised with accessor, setter, and inspectors.

Params:
    Accessor = accessor used to extract data out of From component
    Setter = setter used to set extracted data into To component
    FromInspector = inspector used to inspect From components for accessible fields
    ToInspector = inspector used to inspect To components for settable fields
Returns:
    AdvisedConvertor(To, From) template ready to instantiate a composite convertor for To, and From types using advised accessor, setter, and inspectors.
**/
template MappingConvertorBuilder(alias Accessor, alias Setter, alias ToInspector, alias FromInspector) {
    enum AccessorCheck(To, From) = (is(typeof(Accessor!From()) : PropertyAccessor!(From, Object)));
    enum SetterCheck(To, From) = (is (typeof(Setter!To()) : PropertySetter!(To, Object)));
    enum FromInspectorCheck(To, From) = (is (typeof(FromInspector!From()) : Inspector!From));
    enum ToInspectorCheck(To, From) = (is (typeof(ToInspector!To()) : Inspector!To));

    class MappingConvertorBuilder {
        private {
            Convertor[] convertors_ = [];
        }

        bool conversion = true;
        bool force = true;
        bool skip = true;
        bool throwOnFailure = true;

        this(Convertor[] convertors, bool conversion, bool force, bool skip, bool throwOnFailure) {
            this.convertors = convertors;
            this.conversion = conversion;
            this.force = force;
            this.skip = skip;
            this.throwOnFailure = throwOnFailure;
        }

        this() {

        }

        /**
        Set convertors

        Params:
            convertors = list of convertors used to inject into mapping convertor
        Throws:

        Returns:
            typeof(this)
        **/
        typeof(this) convertors(Convertor[] convertors) @safe nothrow pure
        in {
            assert(convertors !is null, "Cannot build mapping convertor with no convertors");
            assert(convertors.length > 0, "Cannot build mapping convertor with no convertors");
        }
        body {
            this.convertors_ = convertors;

            return this;
        }

        /**
        Get convertors

        Returns:
            Convertor[]
        **/
        inout(Convertor[]) convertors() @safe nothrow pure inout {
            return this.convertors_;
        }

        Convertor make(To, From)() {
            import aermicioi.aedi_property_reader.convertor.mapper : CompositeMapper, CompositeConvertor;
            static if (
                FromInspectorCheck!(To, From) &&
                ToInspectorCheck!(To, From) &&
                AccessorCheck!(To, From) &&
                SetterCheck!(To, From)
            ) {

                auto convertor = new CompositeConvertor!(To, From)();
                CompositeMapper!(To, From) mapper = new CompositeMapper!(To, From)();
                mapper.fromInspector = FromInspector!From();
                mapper.toInspector = ToInspector!To();
                mapper.accessor = Accessor!From();
                mapper.setter = Setter!To();
                mapper.conversion = conversion;
                mapper.force = force;
                mapper.skip = skip;
                convertor.mapper = mapper;
                convertor.convertors = convertors;

                return convertor;
            } else {

                if (this.throwOnFailure) {
                    throw new Exception(this.cause!(To, From));
                } else {
                    error(this.cause!(To, From));
                }

                return null;
            }
        }

        bool isAble(To, From)() {
            return
                FromInspectorCheck!(To, From) &&
                ToInspectorCheck!(To, From) &&
                AccessorCheck!(To, From) &&
                SetterCheck!(To, From);
        }

        string cause(To, From)() {
            return text(
                    "Cannot convert type ",
                    typeid(From),
                    " to ",
                    typeid(To),
                    " when:\n ",
                    fullyQualifiedName!Accessor,
                    " is able to access ", typeid(From), " ",
                    AccessorCheck!(To, From),
                    ",\n ",
                    fullyQualifiedName!Setter,
                    " is able to set ", typeid(To), " ",
                    SetterCheck!(To, From),
                    ",\n ",
                    fullyQualifiedName!FromInspector,
                    " is able to inspect ", typeid(From), " ",
                    FromInspectorCheck!(To, From),
                    ",\n ",
                    fullyQualifiedName!ToInspector,
                    " is able to inspect ", typeid(To), " ",
                    ToInspectorCheck!(To, From)
                );
        }
    }
}

/**
A convertor builder that will scan through all convertor builders and will use first that is able to create a convertor from a source type to a destination type.

Params:
    Builders = list of convertor builders, each able to factory a subset of convertors.
**/
template AnyConvertorBuilder(Builders...)
    if (allSatisfy!(isConvertorBuilder, Builders)) {

    class AnyConvertorBuilder {
        bool throwOnFailure = true;
        Builders builders;

        this(Builders builders, bool throwOnFailure = true) {
            this.builders = builders;
            this.throwOnFailure = throwOnFailure;
        }

        Convertor make(To, From)() {
            if (!this.isAble!(To, From)) {
                if (this.throwOnFailure) {
                    throw new Exception(this.cause!(To, From));
                } else {
                    error(this.cause!(To, From));
                }

                return null;
            }

            foreach (builder; builders) {
                if (builder.isAble!(To, From)) {
                    return builder.make!(To, From);
                }
            }

            throw new Exception(this.cause!(To, From));
        }

        bool isAble(To, From)() {
            foreach (builder; builders) {
                if (builder.isAble!(To, From)) {
                    return true;
                }
            }

            return false;
        }

        string cause(To, From)() {
            if (!this.isAble!(To, From)) {
                string[] messages;

                foreach (builder; builders) {
                    messages ~= text(builder, " failed with: ", builder.cause!(To, From));
                }

                return text(
                    "None of convertor builders were able to convert from ",
                    typeid(From),
                    " to ",
                    typeid(To),
                    " where all of them failed with following errors: ",
                    messages.joiner("\n")
                );
            }

            return null;
        }
    }
}

/**
ditto
**/
auto factoryAnyConvertorBuilder(Builders...)(Builders builders) {
    return new AnyConvertorBuilder!Builders(builders);
}

public {
    enum CompositeAccessorFactory(T) = () => new CompositeAccessor!T;
    enum CompositeSetterFactory(T) = () => new CompositeSetter!T;
    enum CompositeInspectorFactory(T) = () => new CompositeInspector!T;
}

alias MappingConvertorBuilderFactory = (Convertor[] convertors) {
    return new MappingConvertorBuilder!(
        CompositeAccessorFactory,
        CompositeSetterFactory,
        CompositeInspectorFactory,
        CompositeInspectorFactory
    )(convertors, true, true, true, true);
};