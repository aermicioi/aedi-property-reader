/**
License:
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
    Alexandru Ermicioi
**/
module aermicioi.aedi_property_reader.convertor.convertor;

import aermicioi.aedi.configurer.annotation.annotation;
import aermicioi.aedi_property_reader.convertor.exception : ConvertorException;
import aermicioi.aedi_property_reader.convertor.placeholder : identify, unwrap, unpack, pack, stored, original;
import aermicioi.aedi_property_reader.convertor.traits : n, PureSafeNothrowToString;
import taggedalgebraic : TaggedAlgebraic;
import std.array : array, empty, popFront, front;
import std.conv : text;
import std.exception : enforce;
import std.experimental.allocator : RCIAllocator, theAllocator, expandArray, make, makeArray, dispose;
import std.experimental.logger : trace, info, error, fatal, critical;
import std.meta : AliasSeq, allSatisfy, staticMap;
import std.range.primitives : hasLength, hasSlicing, hasAssignableElements, isOutputRange, isForwardRange, ElementType;
import std.range : enumerate;
import std.traits : isSomeFunction, Parameters;
import std.typecons : Flag, Yes, No;
import std.variant : VariantN;


alias ScalarConvertibleTypes = AliasSeq!(
	ubyte, byte, ushort, short, uint, int, ulong, long, float, double, real, char, wchar, dchar
);

alias StringConvertibleTypes = AliasSeq!(
    string, wstring, dstring, char[], wchar[], dchar[]
);

alias ScalarArrayConvertibleTypes = AliasSeq!(
	ubyte[], byte[], ushort[], short[], uint[], int[], ulong[], long[], float[], double[], real[]
);

alias StringArrayConvertibleTypes = AliasSeq!( // TODO add back dstring[] once std.conv is fixed.
    string[], wstring[], char[][], wchar[][], dchar[][]
);

alias MapConvertibleTypes = AliasSeq!(
    string[string], wstring[wstring]
);

alias DefaultConvertibleTypes = AliasSeq!(
    MapConvertibleTypes, StringArrayConvertibleTypes, ScalarArrayConvertibleTypes, ScalarConvertibleTypes, StringConvertibleTypes
);

/**
Interface for components that are able to convert from one erased type to another erased type.
**/
interface Convertor : PureSafeNothrowToString {
    @property {

        /**
        Get the type info of component that convertor can convert from.

        Get the type info of component that convertor can convert from.
        The method is returning the default type that it is able to convert,
        though it is not necessarily limited to this type only. More generalistic
        checks should be done by convertsFrom method.

        Returns:
            type info of component that convertor is able to convert.
        **/
        const(TypeInfo)[] from() @safe const nothrow pure;

        /**
        Get the type info of component that convertor is able to convert to.

        Get the type info of component that convertor is able to convert to.
        The method is returning the default type that is able to convert,
        though it is not necessarily limited to this type only. More generalistic
        checks should be done by convertsTo method.

        Returns:
            type info of component that can be converted to.
        **/
        const(TypeInfo)[] to() @safe const nothrow pure;
    }

    /**
    Check whether convertor is able to convert from.

    Check whether convertor is able to convert from.
    The intent of method is to implement customized type checking
    is not limited immediatly to supported default from component.

    Params:
        from = the type info of component that could potentially be converted by convertor.
    Returns:
        true if it is able to convert from, or false otherwise.
    **/
    bool convertsFrom(const TypeInfo from) @safe const nothrow pure;

    /**
    Check whether convertor is able to convert from.

    Check whether convertor is able to convert from.
    The method will try to extract type info out of from
    object and use for subsequent type checking.
    The intent of method is to implement customized type checking
    is not limited immediatly to supported default from component.

    Params:
        from = the type info of component that could potentially be converted by convertor.
    Returns:
        true if it is able to convert from, or false otherwise.
    **/
    bool convertsFrom(in Object from) @safe const nothrow pure;

    /**
    Check whether convertor is able to convert to.

    Check whether convertor is able to convert to.
    The intent of the method is to implement customized type checking
    that is not limited immediatly to supported default to component.

    Params:
        to = type info of component that convertor could potentially convert to.

    Returns:
        true if it is able to convert to, false otherwise.
    **/
    bool convertsTo(const TypeInfo to) @safe const nothrow pure;

    /**
    Check whether convertor is able to convert to.

    Check whether convertor is able to convert to.
    The method will try to extract type info out of to object and use
    for subsequent type checking.
    The intent of the method is to implement customized type checking
    that is not limited immediatly to supported default to component.

    Params:
        to = type info of component that convertor could potentially convert to.

    Returns:
        true if it is able to convert to, false otherwise.
    **/
    bool convertsTo(in Object to) @safe const nothrow pure;

    /**
    Check whether convertor is able to convert from type to type.

    Check whether convertor is able to convert from type to type.
    This set of methods should be the most precise way of determining
    whether convertor is able to convert from type to type, since it
    provides both components to the decision logic implemented by convertor
    compared to the case with $(D_INLINECODE convertsTo) and $(D_INLINECODE convertsFrom).
    Note that those methods are still useful when categorization or other
    logic should be applied per original or destination type.

    Params:
        from = the original component or it's type to convert from
        to = the destination component or it's type to convert to

    Returns:
        true if it is able to convert from component to destination component
    **/
    bool converts(const TypeInfo from, const TypeInfo to) @safe const nothrow;

    /**
    ditto
    **/
    bool converts(const TypeInfo from, in Object to) @safe const nothrow;

    /**
    ditto
    **/
    bool converts(in Object from, const TypeInfo to) @safe const nothrow;

    /**
    ditto
    **/
    bool converts(in Object from, in Object to) @safe const nothrow;

    /**
    Check whether this convertor is able to destroy to component.

    The destroys family of methods are designed purposely for identification
    whether convertor was able to convert from type to destination to, and
    is eligible for destruction of converted components.

    Params:
        from = original component which was converted.
        to = converted component that should be destroyed by convertor.

    Returns:
        true if convertor is eligible for destroying to, or false otherwise.
    **/
    bool destroys(const TypeInfo from, const TypeInfo to) @safe const nothrow;

    /**
    ditto
    **/
    bool destroys(in Object from, const TypeInfo to) @safe const nothrow;

    /**
    ditto
    **/
    bool destroys(const TypeInfo from, in Object to) @safe const nothrow;

    /**
    ditto
    **/
    bool destroys(in Object from, in Object to) @safe const nothrow;

    /**
    Convert from component to component.

    Params:
        from = original component that is to be converted.
        to = destination object that will be constructed out for original one.
        allocator = optional allocator that could be used to construct to component.
    Throws:
        ConvertorException when there is a converting error
        InvalidArgumentException when arguments passed are not of right type or state
    Returns:
        Resulting converted component.
    **/
    Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator) const;

    /**
    Destroy component created using this convertor.

    Destroy component created using this convertor.
    Since convertor could potentially allocate memory for
    converted component, only itself is containing history of allocation,
    and therefore it is responsible as well to destroy and free allocated
    memory with allocator.

    Params:
        converted = component that should be destroyed.
        allocator = allocator used to allocate converted component.
    Return:
        true if component is destroyed, false otherwise
    **/
    void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const;
}

/**
Default implementation of from method
**/
mixin template FromMixin(FromTypes...) {
    private {
        static immutable TypeInfo[] fromTypes;

        static this() {
            TypeInfo[] infos;

            static foreach (Type; FromTypes) {
                infos ~= typeid(Type);
            }

            fromTypes = cast(immutable) infos;
        }
    }

    @property {
        /**
        Get the type info of component that convertor can convert from.

        Get the type info of component that convertor can convert from.
        The method is returning the default type that it is able to convert,
        though it is not necessarily limited to this type only. More generalistic
        checks should be done by convertsFrom method.

        Returns:
            type info of component that convertor is able to convert.
        **/
        const(TypeInfo)[] from() @safe const nothrow pure {
            return fromTypes;
        }
    }
}

/**
Default implementation of converts from method
**/
mixin template ConvertsFromMixin() {
    import aermicioi.aedi_property_reader.convertor.placeholder : identify;

    /**
    Check whether convertor is able to convert from.

    Check whether convertor is able to convert from.
    The intent of method is to implement customized type checking
    is not limited immediatly to supported default from component.

    Params:
        from = the type info of component that could potentially be converted by convertor.
    Returns:
        true if it is able to convert from, or false otherwise.
    **/
    bool convertsFrom(const TypeInfo from) @safe const nothrow pure {
        import std.algorithm;
        return this.from.canFind!(tested => tested is from);
    }

    /**
    Check whether convertor is able to convert from.

    Check whether convertor is able to convert from.
    The method will try to extract type info out of from
    object and use for subsequent type checking.
    The intent of method is to implement customized type checking
    is not limited immediatly to supported default from component.

    Params:
        from = the type info of component that could potentially be converted by convertor.
    Returns:
        true if it is able to convert from, or false otherwise.
    **/
    bool convertsFrom(in Object from) @safe const nothrow pure {
        return this.convertsFrom(from.identify);
    }
}

/**
Default implementation of to method
**/
mixin template ToMixin(ToTypes...) {
    private {
        static immutable TypeInfo[] toTypes;

        static this() {
            TypeInfo[] infos;

            static foreach (Type; ToTypes) {
                infos ~= typeid(Type);
            }

            toTypes = cast(immutable) infos;
        }
    }

    @property {
        /**
        Get the type info of component that convertor is able to convert to.

        Get the type info of component that convertor is able to convert to.
        The method is returning the default type that is able to convert,
        though it is not necessarily limited to this type only. More generalistic
        checks should be done by convertsTo method.

        Returns:
            type info of component that can be converted to.
        **/
        const(TypeInfo)[] to() @safe const nothrow pure {
            return this.toTypes;
        }
    }
}

/**
Default implementation of converts to method
**/
mixin template ConvertsToMixin() {
    /**
    Check whether convertor is able to convert to.

    Check whether convertor is able to convert to.
    The intent of the method is to implement customized type checking
    that is not limited immediatly to supported default to component.

    Params:
        to = type info of component that convertor could potentially convert to.

    Returns:
        true if it is able to convert to, false otherwise.
    **/
    bool convertsTo(const TypeInfo to) @safe const nothrow pure {
        import std.algorithm;
        return this.to.canFind!(tested => tested is to);
    }

    /**
    Check whether convertor is able to convert to.

    Check whether convertor is able to convert to.
    The method will try to extract type info out of to object and use
    for subsequent type checking.
    The intent of the method is to implement customized type checking
    that is not limited immediatly to supported default to component.

    Params:
        to = type info of component that convertor could potentially convert to.

    Returns:
        true if it is able to convert to, false otherwise.
    **/
    bool convertsTo(in Object to) @safe const nothrow pure {
        return this.convertsTo(to.identify);
    }
}

/**
Default implementation of converts method.
**/
mixin template ConvertsMixin() {
    /**
    Check whether convertor is able to convert from type to type.

    Check whether convertor is able to convert from type to type.
    This set of methods should be the most precise way of determining
    whether convertor is able to convert from type to type, since it
    provides both components to the decision logic implemented by convertor
    compared to the case with $(D_INLINECODE convertsTo) and $(D_INLINECODE convertsFrom).
    Note that those methods are still useful when categorization or other
    logic should be applied per original or destination type.

    Implementation:
        This is default implementation of converts methods which delegate
        the decision to $(D_INLINECODE convertsTo) and $(D_INLINECODE convertsFrom).

    Params:
        from = the original component or it's type to convert from
        to = the destination component or it's type to convert to

    Returns:
        true if it is able to convert from component to destination component
    **/
    bool converts(const TypeInfo from, const TypeInfo to) @safe const nothrow {
        return this.convertsFrom(from) && this.convertsTo(to);
    }

    /**
    ditto
    **/
    bool converts(const TypeInfo from, in Object to) @safe const nothrow {
        return this.convertsFrom(from) && this.convertsTo(to);
    }

    /**
    ditto
    **/
    bool converts(in Object from, const TypeInfo to) @safe const nothrow {
        return this.convertsFrom(from) && this.convertsTo(to);
    }

    /**
    ditto
    **/
    bool converts(in Object from, in Object to) @safe const nothrow {
        return this.convertsFrom(from) && this.convertsTo(to);
    }
}

/**
Default implementation of destroys method.
**/
mixin template DestroysMixin() {
    import aermicioi.aedi_property_reader.convertor.placeholder : original;

    /**
    Check whether this convertor is able to destroy to component.

    The destroys family of methods are designed purposely for identification
    whether convertor was able to convert from type to destination to, and
    is eligible for destruction of converted components.

    Params:
        from = original component which was converted.
        to = converted component that should be destroyed by convertor.

    Returns:
        true if convertor is eligible for destroying to, or false otherwise.
    **/
    bool destroys(const TypeInfo from, const TypeInfo to) @safe const nothrow {
        return this.convertsFrom(from) && this.convertsTo(to);
    }

    /**
    ditto
    **/
    bool destroys(in Object from, const TypeInfo to) @safe const nothrow {
        return this.convertsFrom(from) && this.convertsTo(to);
    }

    /**
    ditto
    **/
    bool destroys(const TypeInfo from, in Object to) @safe const nothrow {
        if (this.convertsFrom(from) && this.convertsTo(to)) {
            if (to.original !is typeid(void)) {
                return this.convertsFrom(to.original);
            }

            return true;
        }

        return false;
    }

    /**
    ditto
    **/
    bool destroys(in Object from, in Object to) @safe const nothrow {
        if (this.convertsFrom(from) && this.convertsTo(to)) {
            if (to.original !is typeid(void)) {
                return this.convertsFrom(to.original);
            }

            return true;
        }

        return false;
    }
}

mixin template ConvertsFromToMixin(FromType, ToType) {
    import aermicioi.aedi_property_reader.convertor.convertor : FromMixin, ToMixin, ConvertsFromMixin, ConvertsToMixin, ConvertsMixin, DestroysMixin;

    mixin FromMixin!FromType;
    mixin ToMixin!ToType;
    mixin ConvertsFromMixin;
    mixin ConvertsToMixin;
    mixin ConvertsMixin;
    mixin DestroysMixin;
}


mixin template ConvertsFromToMixin() {
    import aermicioi.aedi_property_reader.convertor.convertor : ConvertsFromMixin, ConvertsToMixin, ConvertsMixin, DestroysMixin;

    mixin ConvertsFromMixin;
    mixin ConvertsToMixin;
    mixin ConvertsMixin;
    mixin DestroysMixin;
}

/**
Mixin that provides default implementation of equality comparison for convertors
**/
mixin template EqualMixin() {

    override bool opEquals(Object o) {
        return super.opEquals(o) || ((this.classinfo is o.classinfo) && this.opEquals(cast(Convertor) o));
    }

    bool opEquals(Convertor convertor) {
        if (convertor is null) {
            return false;
        }

        if (
            (this.from.length != convertor.from.length) ||
            (this.to.length != convertor.to.length)
        ) {
            return false;
        }

        foreach (index, from; this.from) {
            if (from !is convertor.from[index]) {
                return false;
            }
        }

        foreach (index, to; this.to) {
            if (to !is convertor.to[index]) {
                return false;
            }
        }

        return true;
    }
}

/**
Mixin that provides default implementation of hashing algorithm
**/
mixin template ToHashMixin() {

    override size_t toHash() {
        import std.range : only, chain;
        import std.algorithm : map;
        size_t result = 7;

        foreach (hash; chain(this.from, this.to, this.classinfo.only).map!(ti => ti.toHash)) {
            result = result * 31 + hash;
        }

        return result;
    }
}

/**
Mixin that provides default implementation of toString method
**/
mixin template ToStringMixin() {

    override string toString() @safe nothrow pure {
        import std.string : lastIndexOf;
        import std.conv : text;

        try {
            auto identity = typeid(this).name[typeid(this).name.lastIndexOf(".") + 1 .. $];
            auto from = this.from.length > 2 ? text(this.from[0 .. 2], "...") : text(this.from);
            auto to = this.to.length > 2 ? text(this.to[0 .. 2], "...") : text(this.to);
            return text(
                identity, " [ from: ",  from, ", to: ", to, "]"
            );
        } catch (Exception e) {
            throw new Error("Failed to convert component to string, due to an exception.", e);
        }
    }
}

/**
Default implementation of comparison between two or more convertors.
**/
mixin template OpCmpMixin() {

    override int opCmp(Object o) const {

        auto result = cast(int)cast(void*)this - cast(int)cast(void*)o;

        if (result == 0) {
            result =
                this.classinfo.name < o.classinfo.name ? -1 :
                (this.classinfo.name > o.classinfo.name ? 1 : 0);
        }

        return result;
    }
}

/**
Amalgation of EqualMixin, ToHashMixin, ToStringMixin, and OpCmpMixin
**/
mixin template EqualToHashToStringOpCmpMixin() {
    import aermicioi.aedi_property_reader.convertor.convertor : EqualMixin, ToHashMixin, ToStringMixin, OpCmpMixin;

    mixin EqualMixin!();
    mixin ToHashMixin!();
    mixin ToStringMixin!();
    mixin OpCmpMixin!();
}

/**
A convertor able to unwrap an element out of TaggedAlgebraic!Union.
**/
class TaggedConvertor(Tagged : TaggedAlgebraic!Union, Union) : Convertor {
    import std.traits : Fields, FieldNameTuple;

    mixin FromMixin!Tagged;
    mixin ToMixin!(Fields!Union);

    mixin ConvertsFromToMixin;

    public {

        /**
        ditto
        **/
        bool converts(in Object from, const TypeInfo to) @safe const nothrow {
            if (this.convertsFrom(from)) {
                auto tagged = from.unwrap!Tagged;

                static foreach (field; FieldNameTuple!Union) {
                    if (tagged.kind == mixin("Tagged.Kind." ~ field)) {
                        return mixin("typeid(typeof(Union." ~ field ~ ")) is to");
                    }
                }
            }

            return false;
        }

        /**
        ditto
        **/
        bool converts(in Object from, in Object to) @safe const nothrow {
            return this.converts(from, to.identify);
        }

        /**
        Convert from component to component.

        Convert from component to component.
        In case when functional convertor's from argument is rooted in Object
        class, the convertor will attempt to downcast passed component to
        it's rightfull type. If not, the convertor will attempt to downcast
        from component to placeholding object of value that is accepted by functional
        convertor.
        For converted to component, in case when it is rooted in Object class
        nothing special is performed, while otherwise it will be wrapped into placeholding
        object allocated by allocator that will be returned to callee.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
        {
            enforce!ConvertorException(this.converts(from, to), text(
                "Cannot convert component ", from.identify, " to ", to, " expected original component of ", this.from, " and destination of ", this.to
            ));

            auto tagged = from.unwrap!Tagged;

            static foreach (field; FieldNameTuple!Union) {
                if (tagged.kind == mixin("Tagged.Kind." ~ field)) {

                    debug(trace) trace("Converting ", tagged, " to ", to);
                    return mixin("(cast(typeof(Union." ~ field ~ ")) tagged).pack(from, this, allocator)");
                }
            }

            throw new ConvertorException(text("Could not unwrap tagged element ", from.identify, " to ", to, " expected "));
        }

        /**
        Destroy component created using this convertor.

        Destroy component created using this convertor.
        The method will attempt to downcast converted component
        to type supported by functional destructor when the type is rooted in
        Object class, otherwise it will attempt to downcast converted to placeholding
        object of value supported by functional destructor. In latest case, the
        method will dispose out of placeholding object using passed allocator.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {
            enforce!ConvertorException(this.destroys(from, converted), text(
                "Cannot destroy ", converted.identify, " which was not converted from ", from, ".",
                " Expected destroyable type of ", this.to, " from origin of ", this.from
            ));

            static foreach(Type; Fields!Union) {
                if (converted.identify is typeid(Type)) {

                    debug(trace) trace("Disposing of container for type ", typeid(Type), " if it is value type");
                    converted.unpack!Type(allocator);
                }
            }
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
Interface for convertors that could rely on another convertors to convert a value.
**/
interface CombinedConvertor : Convertor {

    /**
    Set used convertors

    Params:
        convertors = list of convertors to be used.

    Returns:
        typeof(this)
    **/
    typeof(this) convertors(Convertor[] convertors) @safe nothrow;

    /**
    ditto
    **/
    T convertors(this T)(Convertor convertors...) @safe nothrow {
        return this.convertors(convertors.dup);
    }

    /**
    Add a convertor to existing list

    Params:
        convertor = convertor to be added to

    Returns:
        typeof(this)
    **/
    typeof(this) add(Convertor convertor) @safe nothrow;

    /**
    Remove a convertor from existing list

    Params:
        convertor = convertor to be removed

    Returns:
        typeof(this)
    **/
    typeof(this) remove(Convertor convertor) @safe nothrow;
}

/**
A convertor that is delegating converting task to a set of child convertors.
**/
class CombinedConvertorImpl : CombinedConvertor {
    import std.algorithm : canFind, find, map, joiner, filter, any;

    private {
        Convertor[] convertors_;

        private const(TypeInfo)[] fromTypes;
        private const(TypeInfo)[] toTypes;
    }

    public {

        /**
        Default constructor for AggregateConvertor
        **/
        @safe this(Convertor[] convertors...) {
            this.convertors = convertors.dup;
        }

        /**
        Set convertors

        Params:
            convertors = convertors used to convert from one type to another

        Returns:
            typeof(this)
        **/
        typeof(this) convertors(Convertor[] convertors) @trusted nothrow pure
            in (!convertors.empty, "Combined convertor is expecting to have at least one convertor passed to it. None passed")
            in (convertors.all!(c => c !is null), "Encountered null convertor in convertor list received in combined convertor, none are expected") {
            this.convertors_ = convertors;

            this.fromTypes = null;
            this.toTypes = null;

            foreach (convertor; convertors) {
                this.fromTypes ~= convertors.map!(convertor => convertor.from).joiner.filter!(type => this.fromTypes.canFind!(from => type is from)).array;
                this.toTypes ~= convertors.map!(convertor => convertor.to).joiner.filter!(type => this.fromTypes.canFind!(from => type is from)).array;
            }

            return this;
        }

        /**
        Get convertors

        Returns:
            Convertor[]
        **/
        inout(Convertor[]) convertors() @safe nothrow pure inout {
            return this.convertors_;
        }

        /**
        Add a convertor to existing list

        Params:
            convertor = convertor to be added to

        Returns:
            typeof(this)
        **/
        typeof(this) add(Convertor convertor) @trusted nothrow
            in (convertor !is null, "Cannot add null convertor into combined convertor") {
            this.convertors_ ~= convertor;

            this.fromTypes ~= convertor.from.filter!(type => !this.fromTypes.canFind!(from => type is from)).array;
            this.toTypes ~= convertor.from.filter!(type => !this.toTypes.canFind!(to => type is to)).array;

            return this;
        }

        /**
        Remove a convertor from existing list

        Params:
            convertor = convertor to be removed

        Returns:
            typeof(this)
        **/
        typeof(this) remove(Convertor convertor) @trusted nothrow {
            import std.algorithm : remove, countUntil;
            import std.array : array;

            try {

                this.convertors_ = this.convertors_.remove(this.convertors.countUntil!(c => c == convertor));
                this.fromTypes = this.fromTypes.filter!(
                    from => !this.convertors.any!(convertor => convertor.convertsFrom(from))
                ).array;

                this.toTypes = this.fromTypes.filter!(
                    to => !this.convertors.any!(convertor => convertor.convertsTo(to))
                ).array;

            } catch (Exception e) {
                assert(false, text("countUntil threw an exception: ", e));
            }

            return this;
        }

        @property {
            /**
            Get the type info of component that convertor can convert from.

            Get the type info of component that convertor can convert from.
            The method is returning the default type that it is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsFrom method.

            Returns:
                type info of component that convertor is able to convert.
            **/
            const(TypeInfo)[] from() @safe nothrow pure const {
                return fromTypes;
            }

            /**
            Get the type info of component that convertor is able to convert to.

            Get the type info of component that convertor is able to convert to.
            The method is returning the default type that is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsTo method.

            Returns:
                type info of component that can be converted to.
            **/
            const(TypeInfo)[] to() @safe nothrow pure const {
                return toTypes;
            }
        }

        /**
        Check whether convertor is able to convert from.

        Params:
            from = the type info of component that could potentially be converted by convertor.
        Returns:
            true if it is able to convert from, or false otherwise.
        **/
        bool convertsFrom(const TypeInfo from) const {
            return this.convertors.canFind!(c => c.convertsFrom(from));
        }

        /**
        ditto
        **/
        bool convertsFrom(in Object from) const {
            return this.convertors.canFind!(c => c.convertsFrom(from));
        }

        /**
        Check whether convertor is able to convert to.

        Params:
            to = type info of component that convertor could potentially convert to.

        Returns:
            true if it is able to convert to, false otherwise.
        **/
        bool convertsTo(const TypeInfo to) const {
            return this.convertors.canFind!(c => c.convertsTo(to));
        }

        /**
        ditto
        **/
        bool convertsTo(in Object to) const {
            return this.convertors.canFind!(c => c.convertsTo(to));
        }

        /**
        Check whether convertor is able to convert from type to type.

        Check whether convertor is able to convert from type to type.
        This set of methods should be the most precise way of determining
        whether convertor is able to convert from type to type, since it
        provides both components to the decision logic implemented by convertor
        compared to the case with $(D_INLINECODE convertsTo) and $(D_INLINECODE convertsFrom).
        Note that those methods are still useful when categorization or other
        logic should be applied per original or destination type.

        Implementation:
            This is default implementation of converts methods which delegate
            the decision to $(D_INLINECODE convertsTo) and $(D_INLINECODE convertsFrom).

        Params:
            from = the original component or it's type to convert from
            to = the destination component or it's type to convert to

        Returns:
            true if it is able to convert from component to destination component
        **/
        bool converts(const TypeInfo from, const TypeInfo to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.converts(from, to));
        }

        /**
        ditto
        **/
        bool converts(const TypeInfo from, in Object to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.converts(from, to));
        }

        /**
        ditto
        **/
        bool converts(in Object from, const TypeInfo to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.converts(from, to));
        }

        /**
        ditto
        **/
        bool converts(in Object from, in Object to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.converts(from, to));
        }

        /**
        Check whether this convertor is able to destroy to component.

        The destroys family of methods are designed purposely for identification
        whether convertor was able to convert from type to destination to, and
        is eligible for destruction of converted components.

        Params:
            from = original component which was converted.
            to = converted component that should be destroyed by convertor.

        Returns:
            true if convertor is eligible for destroying to, or false otherwise.
        **/
        bool destroys(const TypeInfo from, const TypeInfo to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.destroys(from, to));
        }

        /**
        ditto
        **/
        bool destroys(in Object from, const TypeInfo to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.destroys(from, to));
        }

        /**
        ditto
        **/
        bool destroys(const TypeInfo from, in Object to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.destroys(from, to));
        }

        /**
        ditto
        **/
        bool destroys(in Object from, in Object to) @safe const nothrow {
            return this.convertors.canFind!(convertor => convertor.destroys(from, to));
        }

        /**
        Convert from component to component.

        Finds a right convertor from component to component and uses it
        to execute conversion from component to component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
        {
            auto convertors = this.convertors.find!(c => c.converts(from, to));

            if (!convertors.empty) {
                debug(trace) trace("Converting ", from.identify, " to ", to, " using convertor ", convertors.front);
                return convertors.front.convert(from, to, allocator);
            }

            throw new ConvertorException(text("Could not convert ", typeid(from), " to type ", to));
        }

        /**
        Destroy component created using this convertor.

        Find a suitable convertor for destruction and use it to execute destruction.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {
            enforce!ConvertorException(this.destroys(from, converted), text(
                "Cannot destroy ", converted.identify, " which was not converted from ", from, ".",
                " Expected destroyable type of ", this.to, " from origin of ", this.from
            ));

            auto convertors = this.convertors.find!(c => c.destroys(from, converted));

            if (convertors.empty) {
                throw new ConvertorException(text("No convertor was found to be able to destroy component of ", converted.identify, " converted from ", from));
            }

            debug(trace) trace("Destroying ", converted.identify, " converted from ", from, " using convertor ", convertors.front);
            convertors.front.destruct(from, converted, allocator);
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that simply doesn't do any conversion and returns existing object
**/
class NoOpConvertor : Convertor {

    public {
        mixin FromMixin;
        mixin ToMixin;
        mixin ConvertsFromToMixin;

        /**
        Convert from component to component.

        It will simply pass existing from component as to component
        as consequence requested to component should be same as type info
        of from component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
        {
            enforce!ConvertorException(
                from.identify is to,
                text(
                    "Cannot do no op when expected ",
                    to,
                    " type is not of same type as original from ",
                    from.identify,
                    " type"
                )
            );

            return cast() from;
        }

        /**
        Does not destruct anything since it is not allocating anything.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {

        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that converts a elements of a forward range and puts into an output range that is also a forward range.
**/
@component
class RangeConvertor(To, From) : Convertor
    if (
        isForwardRange!From &&
        isForwardRange!To &&
        __traits(hasMember, To, "put")
    ) {

    private {
        alias InputType = ElementType!From;
        alias OutputType = Parameters!(To.put)[0];

        Convertor convertor_;
    }

    public {
        @property {
            /**
            Set convertor

            Params:
                convertor = convertor used to convert elements from input range and put them into output range.

            Returns:
                typeof(this)
            **/
            @autowired
            typeof(this) convertor(Convertor defaultConvertor) @safe nothrow pure
            in (defaultConvertor !is null, "Cannot accept a null as a convertor, expected one that converts range " ~ typeid(From).toString ~ " to " ~ typeid(To).toString)
            in (defaultConvertor.converts(typeid(InputType), typeid(OutputType)), "Passed convertor is not able to convert range elements from " ~ typeid(InputType).toString ~ " to " ~ typeid(OutputType).toString) {
                this.convertor_ = defaultConvertor;

                return this;
            }

            /**
            Get convertor

            Returns:
                Convertor
            **/
            inout(Convertor) convertor() @safe nothrow pure inout {
                return this.convertor_;
            }
        }

        mixin ConvertsFromToMixin!(From, To) DefaultImplementation;

        /**
        ditto
        **/
        bool converts(in Object from, const TypeInfo to) @safe const nothrow {
            return this.convertsFrom(from) && this.convertsTo(to);
        }

        /**
        ditto
        **/
        bool converts(in Object from, in Object to) @safe const nothrow {
            return this.convertsFrom(from) && this.convertsTo(to);
        }

        /**
        Convert from component to component.

        It will simply pass existing from component as to component
        as consequence requested to component should be same as type info
        of from component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
        {
            enforce!ConvertorException(
                this.convertsFrom(from),
                "Cannot transfer contents of a range ", from.identify, " to output range. Expected range of ", typeid(From)
            );

            enforce!ConvertorException(
                this.convertsTo(to),
                "Cannot transfer contents of range to ", to, " expected an output range of ", typeid(To)
            );

            To output;

            static if (is(To == class)) {
                output = allocator.make!To();
            } else {
                output = To();
            }

            From source = from.unwrap!From;

            debug(trace) trace("Converting range ", from.identify, " to ", to);
            foreach (element; source) {
                auto temporary = source.stored(from, this);
                output.put(this.convertor.convert(temporary, typeid(OutputType), allocator).unpack!OutputType(allocator));
            }

            return output.pack(from, this, allocator);
        }

        /**
        Does not destruct anything since it is not allocating anything.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {
            enforce!ConvertorException(this.destroys(from, converted), text(
                "Cannot destroy ", converted.identify, " which was not converted from ", from, ".",
                " Expected destroyable type of ", this.to, " from origin of ", this.from
            ));

            To destroyable = converted.unpack!To(allocator);

            debug(trace) trace("Destroying converted range ", converted.identify, " constructed from ", from);
            foreach (element; destroyable) {
                auto temporary = element.stored(from, this);
                Object reference = temporary;
                this.convertor.destruct(from, reference, allocator);
            }
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that converts a forward range into an array of it's elements converted to a destination type.
**/
@component
class RangeToArrayConvertor(To : Element[], From, Element) : Convertor
    if (
        isForwardRange!From
    ) {

    private {
        alias InputType = ElementType!From;

        Convertor convertor_;
    }

    public {
        @autowired
        this(Convertor convertor) {
            this.convertor = convertor;
        }

        @property {
            /**
            Set convertor

            Params:
                convertor = convertor used to convert elements from input range and put them into output range.

            Returns:
                typeof(this)
            **/
            @autowired
            typeof(this) convertor(Convertor defaultConvertor) @safe nothrow
            in (defaultConvertor !is null, "Cannot accept a null as a convertor, expected one that converts range " ~ typeid(From).toString ~ " to " ~ typeid(To).toString)
            in (defaultConvertor.converts(typeid(InputType), typeid(Element)), "Passed convertor is not able to convert range elements from " ~ typeid(InputType).toString ~ " to " ~ typeid(Element).toString) {
                this.convertor_ = defaultConvertor;

                return this;
            }

            /**
            Get convertor

            Returns:
                Convertor
            **/
            inout(Convertor) convertor() @safe nothrow pure inout {
                return this.convertor_;
            }
        }

        mixin ConvertsFromToMixin!(From, To);

        /**
        Convert from component to component.

        It will simply pass existing from component as to component
        as consequence requested to component should be same as type info
        of from component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
        {
            enforce!ConvertorException(
                this.convertsFrom(from),
                text("Cannot transfer contents of a range ", from.identify, " to output range. Expected range of ", typeid(From))
            );

            enforce!ConvertorException(
                this.convertsTo(to),
                text("Cannot transfer contents of range to ", to, " expected an array of ", typeid(Element))
            );

            To output;
            From source = from.unwrap!From;

            if (source.empty) {
                return output.pack(from.identify, this, allocator);
            }

            static if (hasLength!From) {
                output = allocator.makeArray!Element(source.length);
            } else {
                output = allocator.makeArray!Element(1);
            }

            debug(trace) trace("Converting range ", from.identify, " to an array of type ", to);
            foreach (indexed; source.enumerate) {
                if (indexed.index == output.length) {
                    allocator.expandArray(output, 1);
                }

                auto temporary = indexed.value.stored(from.identify, this);
                output[indexed.index] = this.convertor.convert(temporary, typeid(Element), allocator).unpack!Element(allocator);
            }

            return output.pack(from.identify, this, allocator);
        }

        /**
        Does not destruct anything since it is not allocating anything.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {
            enforce!ConvertorException(this.destroys(from, converted), text(
                "Cannot destroy ", converted.identify, " which was not converted from ", from, ".",
                " Expected destroyable type of ", this.to, " from origin of ", this.from
            ));

            To destroyable = converted.unpack!To(allocator);

            debug(trace) trace("Destroying array ", to, " converted from original range of type ", from);
            foreach (element; destroyable) {
                auto temporary = element.stored(from.identify, this);
                Object reference = temporary;
                this.convertor.destruct(from, reference, allocator);
            }

            allocator.dispose(destroyable);
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that converts a forward range into an array of it's elements converted to a destination type.
**/
@component
class MapConvertor(To : ToElement[ToKey], From : FromElement[FromKey], ToElement, ToKey, FromElement, FromKey) : Convertor {

    private {
        alias InputType = ElementType!From;

        Convertor elementConvertor_;
        Convertor keyConvertor_;
    }

    public {
        @property {
            /**
            Set convertor

            Params:
                convertor = convertor used to convert elements from input range and put them into output range.

            Returns:
                typeof(this)
            **/
            @autowired
            typeof(this) elementConvertor(Convertor elementConvertor) @safe nothrow pure
            in (elementConvertor !is null, "Cannot accept a null as a convertor, expected one that map value " ~ typeid(FromElement) ~ " to " ~ typeid(ToElement))
            in (elementConvertor.converts(typeid(FromElement), typeid(ToElement)), "Passed convertor is not able to convert map value from " ~ typeid(FromElement) ~ " to " ~ typeid(ToElement)) {
                this.elementConvertor_ = elementConvertor;

                return this;
            }

            /**
            Get convertor

            Returns:
                Convertor
            **/
            inout(Convertor) elementConvertor() @safe nothrow pure inout {
                return this.elementConvertor_;
            }

            /**
            Set convertor

            Params:
                convertor = convertor used to convert elements from input range and put them into output range.

            Returns:
                typeof(this)
            **/
            @autowired
            typeof(this) keyConvertor(Convertor keyConvertor) @safe nothrow pure
            in (keyConvertor !is null, "Cannot accept a null as a convertor, expected one that map key " ~ typeid(FromKey) ~ " to " ~ typeid(ToKey))
            in (keyConvertor.converts(typeid(FromElement), typeid(ToElement)), "Passed convertor is not able to convert map key from " ~ typeid(FromKey) ~ " to " ~ typeid(ToKey)) {
                this.keyConvertor_ = keyConvertor;

                return this;
            }

            /**
            Get convertor

            Returns:
                Convertor
            **/
            inout(Convertor) keyConvertor() @safe nothrow pure inout {
                return this.keyConvertor_;
            }

            /**
            Get the type info of component that convertor can convert from.

            Get the type info of component that convertor can convert from.
            The method is returning the default type that it is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsFrom method.

            Returns:
                type info of component that convertor is able to convert.
            **/
            TypeInfo from() @safe nothrow pure const {
                return typeid(From);
            }

            /**
            Get the type info of component that convertor is able to convert to.

            Get the type info of component that convertor is able to convert to.
            The method is returning the default type that is able to convert,
            though it is not necessarily limited to this type only. More generalistic
            checks should be done by convertsTo method.

            Returns:
                type info of component that can be converted to.
            **/
            TypeInfo to() @safe nothrow pure const {
                return typeid(To);
            }
        }

        /**
        Check whether convertor is able to convert from.

        Params:
            from = the type info of component that could potentially be converted by convertor.
        Returns:
            true if it is able to convert from, or false otherwise.
        **/
        bool convertsFrom(const TypeInfo from) const {
            return this.from is from;
        }

        /**
        ditto
        **/
        bool convertsFrom(in Object from) const {
            return this.convertsTo(from.identify);
        }

        /**
        Check whether convertor is able to convert to.

        Params:
            to = type info of component that convertor could potentially convert to.

        Returns:
            true if it is able to convert to, false otherwise.
        **/
        bool convertsTo(const TypeInfo to) const {
            return this.to is to;
        }

        /**
        ditto
        **/
        bool convertsTo(in Object to) const {
            return this.convertsTo(to.identify);
        }

        mixin ConvertsMixin;

        /**
        Convert from component to component.

        It will simply pass existing from component as to component
        as consequence requested to component should be same as type info
        of from component.

        Params:
            from = original component that is to be converted.
            to = destination object that will be constructed out for original one.
            allocator = optional allocator that could be used to construct to component.
        Throws:
            ConvertorException when convertor is not able to convert from, or to component.
        Returns:
            Resulting converted component.
        **/
        Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
        {
            enforce!ConvertorException(
                this.convertsFrom(from),
                "Cannot transfer contents of a range ", from.identify, " to output range. Expected range of ", typeid(From)
            );

            enforce!ConvertorException(
                this.convertsTo(to),
                "Cannot transfer contents of range to ", to, " expected an array of ", typeid(Element)
            );

            To output;

            From source = from.unwrap!From;

            debug(trace) trace("Converting from associative array of type ", from.identify, " to associative array of ", to);
            foreach (key, value; source) {
                auto keyTemporary = key.stored(from, this);
                auto valueTemporary = value.stored(from, this);

                output[
                    this.keyConvertor.convert(keyTemporary, typeid(ToKey), allocator).unpack!ToKey(allocator)
                ] = this.elementConvertor.convert(valueTemporary, typeid(ToElement), allocator).unpack!ToElement(allocator);
            }

            return output.make(allocator);
        }

        /**
        Does not destruct anything since it is not allocating anything.

        Params:
            converted = component that should be destroyed.
            allocator = allocator used to allocate converted component.
        **/
        void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {
            enforce!ConvertorException(this.destroys(from, converted), text(
                "Cannot destroy ", converted.identify, " which was not converted from ", from, ".",
                " Expected destroyable type of ", this.to, " from origin of ", this.from
            ));

            To destroyable = converted.unpack!To(allocator);

            debug(trace) trace("Destroying keys and values of associative array of ", converted.identify, " converted from ", from);
            foreach (key, element; destroyable) {
                auto keyTemporary = key.stored(from, this);
                auto elementTemporary = element.stored(from, this);

                this.keyConvertor.destruct(from, keyTemporary, allocator);
                this.elementConvertor.destruct(from, elementTemporary, allocator);
            }
        }

        mixin EqualToHashToStringOpCmpMixin!();
    }
}

/**
A convertor that extracts data from a std.variant.VariantN type.
**/
@component
class VariantConvertor(Variant: VariantN!(maxDataSize, Types), size_t maxDataSize, Types...) : Convertor {

    mixin FromMixin!Variant;
    mixin ToMixin!Types;
    mixin ConvertsFromToMixin DefaultConvertsImplementation;
    mixin EqualToHashToStringOpCmpMixin;

    bool converts(in Object from, const TypeInfo to) @safe const nothrow {
        if (this.DefaultConvertsImplementation.converts(from, to)) {
            return from.unwrap!Variant.type is to;
        }

        return false;
    }

    bool converts(in Object from, in Object to) @safe const nothrow {
        return this.converts(from, to.identify);
    }

    /**
    Convert from component to component.

    It will simply pass existing from component as to component
    as consequence requested to component should be same as type info
    of from component.

    Params:
        from = original component that is to be converted.
        to = destination object that will be constructed out for original one.
        allocator = optional allocator that could be used to construct to component.
    Throws:
        ConvertorException when convertor is not able to convert from, or to component.
    Returns:
        Resulting converted component.
    **/
    Object convert(in Object from, const TypeInfo to, RCIAllocator allocator = theAllocator)  const
    {
        enforce!ConvertorException(this.converts(from, to), text(
            "Cannot convert component ", from.identify, " to ", to, " expected original component of ", this.from, " and destination of ", this.to
        ));

        static foreach (Type; Types) {
            if (to is typeid(Type)) {
                return from.unwrap!Variant.get!Type.pack(from, this, allocator);
            }
        }

        assert(false, "Code flow should never get here.");
    }

    /**
    Does not destruct anything since it is not allocating anything.

    Params:
        converted = component that should be destroyed.
        allocator = allocator used to allocate converted component.
    **/
    void destruct(const TypeInfo from, ref Object converted, RCIAllocator allocator = theAllocator) const {
        enforce!ConvertorException(this.destroys(from, converted), text(
            "Cannot destroy component ", to.identify, ". Passed component isn't converted by this convertor"
        ));

        static foreach (Type; Types) {
            if (converted.identify is typeid(Type)) {
                converted.unpack!Type(allocator);
            }
        }
    }
}

/**
Convert from into component of type To using a convertor for this.

Params:
    convertor = the convertor used to convert from component into To
    from = original component that is to be converted
    allocator = optional allocator used to allocate memory for converted component

Returns:
    To converted component
**/
To convert(To, From)(Convertor convertor, From from, RCIAllocator allocator = theAllocator) {
    return convertor.convert(from.stored, typeid(To), allocator).unpack!To;
}