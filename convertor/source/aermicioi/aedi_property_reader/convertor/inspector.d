/**
License:
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
    Alexandru Ermicioi
**/
module aermicioi.aedi_property_reader.convertor.inspector;

import std.traits;
import std.meta;
import std.exception;
import std.conv;
import aermicioi.util.traits : isPropertyGetter, isPropertySetter, isPublic, isField;
import aermicioi.aedi : NotFoundException;
import aermicioi.aedi_property_reader.convertor.placeholder : unwrap, identify;
import aermicioi.aedi_property_reader.convertor.traits : isD;
import taggedalgebraic;

/**
Provides type and field information of a composite component at runtime.
**/
interface Inspector(ComponentType, KeyType = string) {

    /**
    Identify the type of child field of component.

    Params:
        component = a composite component (class, struct, assoc array etc.) containing some fields

    Returns:
        Type of field, or typeid(void) if field is not present in component
    **/
    TypeInfo typeOf(ComponentType component, in KeyType property) const nothrow;

    /**
    Identify the type of component itself.

    Identify the type of component itself. It will inspect the component and will return accurate
    type info that the component represents.

    Params:
        component = component which should be identified.

    Returns:
        Type info of component, or typeid(void) if component cannot be identified by inspector
    **/
    TypeInfo typeOf(ComponentType component) const nothrow;

    /**
    Check if component has a field or a property.

    Params:
        component = component with fields
        property = component property that is tested for existence

    Returns:
        true if field is present either in readonly, or writeonly form (has getters and setters).
    **/
    bool has(ComponentType component, in KeyType property) const nothrow;

    /**
    Return a list of properties that component holds.

    Params:
        component = the component with fields

    Returns:
        an arary of property identities.
    **/
    KeyType[] properties(ComponentType component) const nothrow;
}

/**
Associative array inspector.
**/
class AssociativeArrayInspector(ComponentType, KeyType = ComponentType) : Inspector!(ComponentType[KeyType], KeyType) {

    /**
    Identify the type of child field of component.

    Params:
        component = a composite component (class, struct, assoc array etc.) containing some fields

    Returns:
        Type of field, or typeid(void) if field is not present in component
    **/
    TypeInfo typeOf(ComponentType[KeyType] component, in KeyType property) const nothrow {

        return typeid(ComponentType);
    }

    /**
    Identify the type of component itself.

    Identify the type of component itself. It will inspect the component and will return accurate
    type info that the component represents.

    Params:
        component = component which should be identified.

    Returns:
        Type info of component, or typeid(void) if component cannot be identified by inspector
    **/
    TypeInfo typeOf(ComponentType[KeyType] component) const nothrow {
        return typeid(ComponentType[KeyType]);
    }

    /**
    Check if component has a field or a property.

    Params:
        component = component with fields
        property = component property that is tested for existence

    Returns:
        true if field is present either in readonly, or writeonly form (has getters and setters).
    **/
    bool has(ComponentType[KeyType] component, in KeyType property) const nothrow {
        return (property in component) !is null;
    }

    /**
    Return a list of properties that component holds.

    Params:
        component = the component with fields

    Returns:
        an arary of property identities.
    **/
    KeyType[] properties(ComponentType[KeyType] component) const nothrow {
        import std.array : array;

        return component.byKey.array;
    }
}

/**
Array inspector
**/
class ArrayInspector(ComponentType) : Inspector!(ComponentType[], size_t) {

    /**
    Identify the type of child field of component.

    Params:
        component = a composite component (class, struct, assoc array etc.) containing some fields

    Returns:
        Type of field, or typeid(void) if field is not present in component
    **/
    TypeInfo typeOf(ComponentType[] component, in size_t property) const nothrow {
        if (property < component.length) {

            return typeid(ComponentType);
        }

        return typeid(void);
    }

    /**
    Identify the type of component itself.

    Identify the type of component itself. It will inspect the component and will return accurate
    type info that the component represents.

    Params:
        component = component which should be identified.

    Returns:
        Type info of component, or typeid(void) if component cannot be identified by inspector
    **/
    TypeInfo typeOf(ComponentType[] component) const nothrow {
        return typeid(ComponentType[]);
    }

    /**
    Check if component has a field or a property.

    Params:
        component = component with fields
        property = component property that is tested for existence

    Returns:
        true if field is present either in readonly, or writeonly form (has getters and setters).
    **/
    bool has(ComponentType[] component, in size_t property) const nothrow {
        return component.length > property;
    }

    /**
    Return a list of properties that component holds.

    Params:
        component = the component with fields

    Returns:
        an arary of property identities.
    **/
    size_t[] properties(ComponentType[] component) const nothrow {
        import std.array : array;
        import std.range : iota;

        return iota(component.length).array;
    }
}

/**
An inspector that is able to inspect tagged types, and provide insights for them.
**/
class TaggedInspector(Tagged : TaggedAlgebraic!(Union), Type, Union) : Inspector!Tagged
    if (anySatisfy!(ApplyRight!(isD, Type), Fields!Union)) {
    import std.experimental.logger : error;
    import aermicioi.aedi_property_reader.convertor.traits : n;

    private {
        Inspector!Type inspector_;
    }

    /**
    Constructs TaggedInspector

    Params:
        inspector = underlying inspector that is able to inspect just one subtype of tagged type
    **/
    this(Inspector!Type inspector) {
        this.inspector = inspector;
    }

    @property {
        /**
        Set inspector

        Params:
            inspector = inspector used to inspect underlying tagged value

        Returns:
            typeof(this)
        **/
        typeof(this) inspector(Inspector!Type inspector) @safe nothrow pure {
            this.inspector_ = inspector;

            return this;
        }

        /**
        Get inspector

        Returns:
            Inspector!Type
        **/
        inout(Inspector!Type) inspector() @safe nothrow pure inout {
            return this.inspector_;
        }
    }

    /**
    Identify the type of child field of component.

    Params:
        component = a composite component (class, struct, assoc array etc.) containing some fields

    Returns:
        Type of field, or typeid(void) if field is not present in component
    **/
    TypeInfo typeOf(Tagged component, in string property) const nothrow {
        try {

            import std.meta : staticMap;
            import aermicioi.util.traits.traits : identifier;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Union." ~ e ~ ") : Type)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return typeid(Tagged);
                    }

                    debug(trace) error(
                        "Could not identify tagged algebraic's ",
                        typeid(component),
                        " inner type, returning void."
                    ).n;

                    return typeid(void);
                }
            }

        } catch (Exception e) {
            debug(trace) error("Failed to unwrap tagged component ", component, " due to ", e, " returning void").n;
        }

        return typeid(void);
    }

    /**
    Identify the type of component itself.

    Identify the type of component itself. It will inspect the component and will return accurate
    type info that the component represents.

    Params:
        component = component which should be identified.

    Returns:
        Type info of component, or typeid(void) if component cannot be identified by inspector
    **/
    TypeInfo typeOf(Tagged component) const nothrow {
        try {

            import std.meta : staticMap;
            import aermicioi.util.traits.traits : identifier;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Union." ~ e ~ ") : Type)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return typeid(Tagged);
                    }

                    return typeid(void);
                }
            }

        } catch (Exception e) {
            debug(trace) error("Failed to unwrap tagged component ", component, " due to ", e).n;
        }

        return typeid(void);
    }

    /**
    Check if component has a field or a property.

    Params:
        component = component with fields
        property = component property that is tested for existence

    Returns:
        true if field is present either in readonly, or writeonly form (has getters and setters).
    **/
    bool has(Tagged component, in string property) const nothrow {
        try {

            import std.meta : staticMap;
            import aermicioi.util.traits.traits : identifier;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Union." ~ e ~ ") : Type)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return this.inspector.has(cast(Type) component, property);
                    }

                    return false;
                }
            }

        } catch (Exception e) {
            debug(trace) error("Failed to unwrap tagged component ", component, " due to ", e).n;
        }

        return false;
    }

    /**
    Return a list of properties that component holds.

    Params:
        component = the component with fields

    Returns:
        an arary of property identities.
    **/
    string[] properties(Tagged component) const nothrow {
        try {

            import std.meta : staticMap;
            import aermicioi.util.traits.traits : identifier;

            static foreach (e; staticMap!(identifier, EnumMembers!(Tagged.Kind))) {
                static if (mixin("is(typeof(Union." ~ e ~ ") : Type)")) {
                    if (mixin("component.Kind." ~ e ~ " == component.kind")) {

                        return this.inspector.properties(cast(Type) component);
                    }
                }
            }

        } catch (Exception e) {
            debug(trace) error("Failed to unwrap tagged component ", component, " due to ", e).n;
        }

        return [];
    }
}

/**
Inspector for composite components (structs, objects, unions, etc.).
**/
class CompositeInspector(ComponentType) : Inspector!(ComponentType, string)
    if (isAggregateType!ComponentType) {

    /**
    Identify the type of child field of component.

    Params:
        component = a composite component (class, struct, assoc array etc.) containing some fields

    Returns:
        Type of field, or typeid(void) if field is not present in component
    **/
    TypeInfo typeOf(ComponentType component, in string property) const nothrow {
        if (this.has(component, property)) {
            static foreach (member; __traits(allMembers, ComponentType)) {
                static if (isPublic!(ComponentType, member)) {{
                    alias m = Alias!(__traits(getMember, component, member));
                    if (member == property) {
                        static if (
                            isField!(ComponentType, member) ||
                            (
                                isSomeFunction!m &&
                                anySatisfy!(isPropertyGetter, __traits(getOverloads, component, member))
                            )
                        ) {

                            return typeid(typeof(__traits(getMember, component, member)));
                        }
                    }
                }}
            }
        }


        return typeid(void);
    }

    /**
    Identify the type of component itself.

    Identify the type of component itself. It will inspect the component and will return accurate
    type info that the component represents.

    Params:
        component = component which should be identified.

    Returns:
        Type info of component, or typeid(void) if component cannot be identified by inspector
    **/
    TypeInfo typeOf(ComponentType component) const nothrow {
        return typeid(ComponentType);
    }

    /**
    Check if component has a field or a property.

    Params:
        component = component with fields
        property = component property that is tested for existence

    Returns:
        true if field is present either in readonly, or writeonly form (has getters and setters).
    **/
    bool has(ComponentType component, in string property) const nothrow {
        import std.algorithm : canFind;
        return this.properties(component).canFind(property);
    }

    /**
    Return a list of properties that component holds.

    Params:
        component = the component with fields

    Returns:
        an arary of property identities.
    **/
    string[] properties(ComponentType component) const nothrow {
        string[] props;

        static foreach (member; __traits(allMembers, ComponentType)) {
            static if (isPublic!(ComponentType, member)) {{
                static if (
                    isField!(ComponentType, member) ||
                    (isSomeFunction!(__traits(getMember, component, member)) && (
                        anySatisfy!(isPropertyGetter, __traits(getOverloads, component, member)) ||
                        anySatisfy!(isPropertySetter, __traits(getOverloads, component, member))

                    ))) {
                    props ~= member;
                }
            }}
        }

        return props;
    }
}

/**
An inspector that accepts a component with erased type for inspecting.

An inspector that accepts a component with erased type for inspecting. It will
attempt to downcast the component to rightful type, if Type is rooted into Object
or it will attempt to downcast to object implementing Placeholder!Type interface
that effectively is storage for inspected component.
**/
class RuntimeInspector(Type, KeyType = string) : Inspector!(Object, KeyType) {
    private {
        Inspector!(Type, KeyType) inspector_;
    }

    public {

        /**
        Constructor for RuntimeInspector

        Params:
            inspector = underlying inspector that works with unwrapped type
        **/
        this(Inspector!(Type, KeyType) inspector) {
            this.inspector = inspector;
        }

        @property {
            /**
            Set inspector

            Params:
                inspector = underlying inspector used to extract data

            Returns:
                typeof(this)
            **/
            typeof(this) inspector(Inspector!(Type, KeyType) inspector) @safe nothrow pure {
                this.inspector_ = inspector;

                return this;
            }

            /**
            Get inspector

            Returns:
                Inspector!Type
            **/
            inout(Inspector!(Type, KeyType)) inspector() @safe nothrow pure inout {
                return this.inspector_;
            }
        }

        /**
        Identify the type of child field of component.

        Params:
            component = a composite component (class, struct, assoc array etc.) containing some fields

        Returns:
            Type of field, or typeid(void) if field is not present in component
        **/
        TypeInfo typeOf(Object wrapped, in KeyType property) const nothrow {
            if (wrapped.identify is typeid(Type)) {

                return this.inspector.typeOf(wrapped.unwrap!Type, property);
            }

            return typeid(void);
        }

        /**
        Identify the type of component itself.

        Identify the type of component itself. It will inspect the component and will return accurate
        type info that the component represents.

        Params:
            component = component which should be identified.

        Returns:
            Type info of component, or typeid(void) if component cannot be identified by inspector
        **/
        TypeInfo typeOf(Object component) const nothrow {
            if (component.identify is typeid(Type)) {

                return this.inspector.typeOf(component.unwrap!Type);
            }

            return typeid(void);
        }

        /**
        Guess the D type of serialized based on information available in it.

        Params:
            serialized = the component for which guesser will attempt to guess the type.

        Returns:
            TypeInfo guessed type
        **/
        TypeInfo guess(Object serialized) {
            TypeInfo type = this.typeOf(serialized);

            if (type is typeid(void)) {
                return serialized.classinfo;
            }

            return type;
        }

        /**
        Check if component has a field or a property.

        Params:
            component = component with fields
            property = component property that is tested for existence

        Returns:
            true if field is present either in readonly, or writeonly form (has getters and setters).
        **/
        bool has(Object wrapped, in KeyType property) const nothrow {
            return this.inspector.has(wrapped.unwrap!Type, property);
        }

        /**
        Return a list of properties that component holds.

        Params:
            component = the component with fields

        Returns:
            an arary of property identities.
        **/
        KeyType[] properties(Object wrapped) const nothrow {
            return this.inspector.properties(wrapped.unwrap!Type);
        }
    }
}

/**
Provides type and field information of a composite component at runtime.
**/
class CombinedInspector(ComponentType, KeyType = string) : Inspector!(ComponentType, KeyType) {

    private {
        Inspector!(ComponentType, KeyType) inspectors_;
    }

    /**
    Set inspectors

    Params:
        inspectors = list of inspectors used to inspect the type

    Returns:
        typeof(this)
    **/
    typeof(this) inspectors(Inspector!(ComponentType, KeyType)[] inspectors) @safe nothrow pure {
        this.inspectors_ = inspectors;

        return this;
    }

    /**
    Set inspectors

    Params:
        inspectors = list of inspectors used to inspect the type

    Returns:
        typeof(this)
    **/
    typeof(this) inspectors(Inspector!(ComponentType, KeyType) inspectors...) @safe nothrow pure {
        this.inspectors_ = inspectors.dup;

        return this;
    }

    /**
    Get inspectors

    Returns:
        Inspector!(ComponentType, KeyType)[]
    **/
    inout(Inspector!(ComponentType, KeyType)) inspectors() @safe nothrow pure inout {
        return this.inspectors_;
    }

    /**
    Identify the type of child field of component.

    Params:
        component = a composite component (class, struct, assoc array etc.) containing some fields

    Returns:
        Type of field, or typeid(void) if field is not present in component
    **/
    TypeInfo typeOf(ComponentType component, in KeyType property) const nothrow {
        foreach (inspector; this.inspectors) {
            TypeInfo type = inspector.typeOf(component, property);

            if (type !is typeid(void)) {
                return type;
            }
        }

        return typeid(void);
    }

    /**
    Identify the type of component itself.

    Identify the type of component itself. It will inspect the component and will return accurate
    type info that the component represents.

    Params:
        component = component which should be identified.

    Returns:
        Type info of component, or typeid(void) if component cannot be identified by inspector
    **/
    TypeInfo typeOf(ComponentType component) const nothrow {
        foreach (inspector; this.inspectors) {
            TypeInfo type = inspector.typeOf(component);

            if (type !is typeid(void)) {
                return type;
            }
        }

        return typeid(void);
    }

    /**
    Check if component has a field or a property.

    Params:
        component = component with fields
        property = component property that is tested for existence

    Returns:
        true if field is present either in readonly, or writeonly form (has getters and setters).
    **/
    bool has(ComponentType component, in KeyType property) const nothrow {
        foreach (inspector; this.inspectors) {
            if (inspector.has(component, property)) {
                return true;
            }
        }

        return false;
    }

    /**
    Return a list of properties that component holds.

    Params:
        component = the component with fields

    Returns:
        an arary of property identities.
    **/
    KeyType[] properties(ComponentType component) const nothrow {
        return this.inspectors.map!(i => i.properties).joiner.array;
    }
}