/**
License:
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
    Alexandru Ermicioi
**/
module aermicioi.aedi_property_reader.convertor.placeholder;

import aermicioi.aedi : Wrapper;
import aermicioi.aedi_property_reader.convertor.traits : n;
import aermicioi.aedi_property_reader.convertor.convertor : Convertor;
import std.experimental.allocator;
import std.conv;
import std.traits : Unqual;
import std.typecons : scoped;

/**
Interface for objects that are aware of a type and can provide it.
**/
interface TypeAware {

    /**
    Get the type that is stored in component.

    Returns:
        TypeInfo stored in component.
    **/
    const(TypeInfo) type() const nothrow @property @nogc pure;
}

/**
Interface for objects that are aware of original type from which containing value was created.
**/
interface OriginalTypeAware {

    /**
    Get the type of original component from which contained one was created/converted.

    Returns:
        TypeInfo of original component
    **/
    const(TypeInfo) original() const @property nothrow @nogc pure;
}

/**
Interface for objects that are aware of convertor used to convert to destination type component stored in the implementor.
**/
interface ConvertorAware {

    /**
    Get the convertor used to convert component stored in implementor of this interface.

    Returns:
        Convertor used to convert component stored by implementor of this interface
    **/
    const(Convertor) convertor() const @property nothrow @nogc pure;
}

/**
Interface for objects aware of allocator used in conversion of contained component.
**/
interface AllocatorAware {

    /**
    Get allocator used in conversion of component stored in implementor.

    Returns:
        Allocator used to convert component stored by implementor of this interface.
    **/
    inout(RCIAllocator) allocator() inout @property nothrow @nogc pure;
}

/**
Interface for objects that can hold a value in.
**/
interface Placeholder(T) {

    @property {

        /**
        Get stored value.

        Returns:
            T value stored in component
        **/
        ref inout(T) value() nothrow @safe inout @nogc;

        /**
        Store value in component.

        Params:
            value = value that will be stored in.

        Returns:
            Reference to stored value.
        **/
        ref T value(ref T value) nothrow @safe;

        /**
        ditto
        **/
        final ref T value(T value) nothrow @safe {
            return this.value(value);
        }

    }
}

/**
Interface for components that are able to destroy component contained in them using convertor, allocator, and original type converted from.
**/
interface Destroyable {

    /**
    Destroy contained component using convertor and additional information available.

    Returns:
        true if it was able to destroy, false otherwise.
    **/
    bool destruct() @safe nothrow;
}

/**
Implementation of Placeholder!T.
**/
class PlaceholderImpl(T) : Placeholder!T, Wrapper!T, TypeAware, AllocatorAware {

    private {
        T payload;
        RCIAllocator allocator_;
    }

    /**
    Constructor for placeholder accepting stored value.

    Params:
        value = value that will be stored in.
    **/
    this(ref T value, RCIAllocator allocator = theAllocator) nothrow {
        this.payload = value;
        this.allocator_ = allocator;
    }

    this(ref const T value, RCIAllocator allocator = theAllocator) nothrow const {
        this.payload = value;
        this.allocator_ = allocator;
    }

    this(ref immutable T value, immutable RCIAllocator allocator) nothrow immutable {
        this.payload = value;
        this.allocator_ = allocator;
    }

    /**
    ditto
    **/
    this(T value, RCIAllocator allocator = theAllocator) nothrow {
        this(value, allocator);
    }

    /**
    ditto
    **/
    this(const T value, RCIAllocator allocator = theAllocator) nothrow const {
        this(value, allocator);
    }

    /**
    ditto
    **/
    this(immutable T value, immutable RCIAllocator allocator) nothrow immutable {
        this(value, allocator);
    }

    @property {
        /**
        Get the type of component that is stored in.

        Returns:
            TypeInfo of stored component.
        **/
        TypeInfo type() const nothrow @nogc pure {
            return typeid(T);
        }

        /**
        Get allocator

        Returns:
            RCIAllocator
        **/
        inout(RCIAllocator) allocator() @safe nothrow pure inout {
            return this.allocator_;
        }

        /**
        Store value in component.

        Params:
            value = value that will be stored in.

        Returns:
            Reference to stored value.
        **/
        ref T value(ref T value) nothrow @safe {
            static if (!is(T == const) && !is(T == immutable)) {
                import std.algorithm : move;

                value.move(this.payload);
            }

            return this.payload;
        }

        /**
        Get value

        Returns:
            ref inout(T)
        **/
        ref inout(T) value() @safe nothrow inout @nogc {
            return this.payload;
        }
    }
}

/**
Implementation of Placeholder!T.
**/
class OriginalAwarePlaceholderImpl(T) : PlaceholderImpl!T, OriginalTypeAware {

    private {
        const TypeInfo original_;
    }

    /**
    Constructor for placeholder accepting stored value.

    Params:
        value = value that will be stored in.
    **/
    this(ref T value, const TypeInfo original, RCIAllocator allocator = theAllocator) nothrow
    in (original !is null, "Placeholder expects original type to be provided, not null.") {
        super(value, allocator);
        this.original_ = original;
    }

    this(ref const T value, const TypeInfo original, RCIAllocator allocator = theAllocator) nothrow const
    in (original !is null, "Placeholder expects original type to be provided, not null.") {
        super(value, allocator);
        this.original_ = original;
    }

    this(ref immutable T value, immutable TypeInfo original, immutable RCIAllocator allocator) nothrow immutable
    in (original !is null, "Placeholder expects original type to be provided, not null.") {
        super(value, allocator);
        this.original_ = original_;
    }

    /**
    ditto
    **/
    this(T value, const TypeInfo original, RCIAllocator allocator = theAllocator) nothrow {
        this(value, original, allocator);
    }

    /**
    ditto
    **/
    this(const T value, const TypeInfo original, RCIAllocator allocator = theAllocator) nothrow const {
        this(value, original, allocator);
    }

    /**
    ditto
    **/
    this(immutable T value, immutable TypeInfo original, immutable RCIAllocator allocator) nothrow immutable {
        this(value, original, allocator);
    }

    @property {

        /**
        Get the type of original component from which contained one was created/converted.

        Returns:
            TypeInfo of original component
        **/
        const(TypeInfo) original() const nothrow @nogc pure {
            return this.original_;
        }
    }
}

/**
Implementation of Placeholder!T.
**/
class ConvertorAndOriginalAwarePlaceholderImpl(T) : OriginalAwarePlaceholderImpl!T, ConvertorAware {

    private {
        const Convertor convertor_;
    }

    /**
    Constructor for placeholder accepting stored value.

    Params:
        value = value that will be stored in.
    **/
    this(ref T value, const TypeInfo original, const Convertor convertor, RCIAllocator allocator = theAllocator) nothrow
    in (convertor !is null, "Placeholder expects convertor of component to be provided, not null.") {
        super(value, original, allocator);
        this.convertor_ = convertor;
    }

    this(ref const T value, const TypeInfo original, const Convertor convertor, RCIAllocator allocator = theAllocator) nothrow const
    in (convertor !is null, "Placeholder expects convertor of component to be provided, not null.") {
        super(value, original, allocator);
        this.convertor_ = convertor;
    }

    this(ref immutable T value, immutable TypeInfo original, immutable Convertor convertor, immutable RCIAllocator allocator) nothrow immutable
    in (convertor !is null, "Placeholder expects convertor of component to be provided, not null.") {
        super(value, original, allocator);
        this.convertor_ = convertor_;
    }

    /**
    ditto
    **/
    this(T value, const TypeInfo original, const Convertor convertor, RCIAllocator allocator = theAllocator) nothrow {
        this(value, original, convertor, allocator);
    }

    /**
    ditto
    **/
    this(const T value, const TypeInfo original, const Convertor convertor, RCIAllocator allocator = theAllocator) nothrow const {
        this(value, original, convertor, allocator);
    }

    /**
    ditto
    **/
    this(immutable T value, immutable TypeInfo original, immutable Convertor convertor, immutable RCIAllocator allocator) nothrow immutable {
        this(value, original, convertor, allocator);
    }

    @property {

        /**
        Get the type of original component from which contained one was created/converted.

        Returns:
            TypeInfo of original component
        **/
        const(Convertor) convertor() const nothrow @nogc pure {
            return this.convertor_;
        }
    }
}

/**
Wrap up a value in a placeholding object.

Params:
    value = value that will be wrapped in placeholding object
    from = original type from which value was converted
    convertor = convertor used in converting value out of from
    allocator = allocator used to allocate placeholding object

Returns:
    Placeholder!T with value as content.
**/
ConvertorAndOriginalAwarePlaceholderImpl!T pack(T, From)(auto ref T value, const From from, const Convertor convertor, RCIAllocator allocator = theAllocator) @trusted {
    return allocator.make!(ConvertorAndOriginalAwarePlaceholderImpl!T)(value, from.identify, convertor, allocator);
}

/**
ditto
**/
OriginalAwarePlaceholderImpl!T pack(T, From)(auto ref T value, const From from, RCIAllocator allocator = theAllocator) @trusted {
    return allocator.make!(OriginalAwarePlaceholderImpl!T)(value, from.identify, allocator);
}

/**
ditto
**/
PlaceholderImpl!T pack(T)(auto ref T value, RCIAllocator allocator = theAllocator) @trusted {
    return allocator.make!(PlaceholderImpl!T)(value, allocator);
}

/**
ditto
**/
auto packWithStorageClass(alias StorageType, T)(auto ref T value, const TypeInfo from, const Convertor convertor, RCIAllocator allocator = theAllocator) @trusted {

    return pack!(StorageType!T)(cast(StorageType!T) value, from, convertor, allocator);
}

/**
ditto
**/
auto packWithStorageClass(alias StorageType, T)(auto ref T value, const TypeInfo from, RCIAllocator allocator = theAllocator) @trusted {

    return pack!(StorageType!T)(cast(StorageType!T) value, from, allocator);
}

/**
ditto
**/
auto packWithStorageClass(alias StorageType, T)(auto ref T value, RCIAllocator allocator = theAllocator) @trusted {

    return pack!(StorageType!T)(cast(StorageType!T) value, allocator);
}

/**
Wrap up a value in a placeholding object stored on stack instead of allocator.

Params:
    value = value that will be wrapped in placeholding object

Returns:
    scoped Placeholder!T with value as content.
**/
auto stored(T)(auto ref T value, const TypeInfo from, const Convertor convertor) {
    import std.typecons : scoped;

    return scoped!(ConvertorAndOriginalAwarePlaceholderImpl!T)(value, from, convertor, RCIAllocator());
}

/**
ditto
**/
auto stored(T)(auto ref T value, const TypeInfo from) {
    import std.typecons : scoped;

    return scoped!(OriginalAwarePlaceholderImpl!T)(value, from, RCIAllocator());
}

/**
ditto
**/
auto stored(T)(auto ref T value) {
    import std.typecons : scoped;

    return scoped!(PlaceholderImpl!T)(value, RCIAllocator());
}

/**
Downcast object to type T, or unwrap it from Placeholder!T.

Downcast object to type T, or unwrap it from Placeholder!T.
If T is rooted in Object, downcast will be performed, otherwise
it is assumed that T is stored in Placeholder!T object, and therefore
object is downcast to Placeholder!T and then returned.

Params:
    object = object from which to unwrap value of type T
Returns:
    T if it is rooted in Object, or Placeholder!T if it is not.
**/
auto ref T unwrap(T)(inout(Object) object) @trusted nothrow {
    static if (is(T : Object) || is(T : const Object) || is(T : immutable Object) || is(T : inout(Object))) {
        {
            auto downcasted = cast(T) object;

            if (downcasted !is null) {
                return downcasted;
            }
        }
    }

    {
        auto downcasted = cast(Placeholder!T) object;

        if (downcasted !is null) {
            return downcasted.value;
        }
    }

    assert(false, text(object.identify, " does not implement", typeid(T), ". inout(Object) cannot be extracted."));
}

/**
ditto
**/
auto ref T unwrap(T : Placeholder!Z, Z)(T placeholder) @trusted nothrow {
    return placeholder;
}

auto ref T unwrap(T : typeof(null))(inout(Object) object) {
    if (object is null) {
        return null;
    }

    Placeholder!T placeholder = cast(Placeholder!T) object;

    if (placeholder !is null) {
        return placeholder.value;
    }

    assert(false, text(object.identify, " is not of ", typeid(null)));
}

/**
Downcast object to type T, or destructively unwrap it from Placeholder!T.

Downcast object to type T, or destructively unwrap it from Placeholder!T.
If T is rooted in Object, downcast will be performed, otherwise
it is assumed that T is stored in Placeholder!T object, and therefore
object is downcast to Placeholder!T it's value extracted and placeholder itself is
disposed of.

Params:
    object = object from which to unwrap value of type T
Returns:
    T if it is rooted in Object, or Placeholder!T if it is not.
**/
T unpack(T)(Object object, RCIAllocator allocator = theAllocator) @trusted {
    import aermicioi.aedi_property_reader.convertor.traits : n;
    static if (is(T : Object) || is(T : const Object) || is(T : immutable Object) || is(T : inout(Object))) {
        {
            auto downcasted = cast(T) object;

            if (downcasted !is null) {
                return downcasted;
            }
        }
    }

    {
        auto downcasted = cast(Placeholder!T) object;

        if (downcasted !is null) {
            return downcasted.unpack;
        }
    }

    assert(false, text(object.identify, " does not implement", typeid(T), ". inout(Object) cannot be extracted."));
}

T unpack(T : typeof(null))(Object object, RCIAllocator allocator = theAllocator) @trusted {
    import aermicioi.aedi_property_reader.convertor.traits : n;
    if (object is null) {
        return null;
    }

    {
        auto downcasted = cast(Placeholder!T) object;

        if (downcasted !is null) {
            return downcasted.unpack;
        }
    }

    assert(false, text(object.identify, " does not implement", typeid(T), ". inout(Object) cannot be extracted."));
}

/**
ditto
**/
Z unpack(T : Placeholder!Z, Z)(T placeholder, RCIAllocator allocator = theAllocator) @trusted nothrow {
    try {
        scope(exit) allocator.dispose(placeholder);

        return placeholder.value;
    } catch (Exception e) {
        throw new Error("Failed to dispose placeholder for a value", e);
    }
}

/**
Identify the type of object.

Identify the type of object.
The object will be downcasted to TypeAware first, in order
to test if object is holding information about some type.
If so, the type from TypeAware object will be returned,
otherwise classinfo of object itself.

Params:
    object = component to be identified
Returns:
    TypeInfo of stored type of object implements TypeAware, or classinfo of object itself.
**/
const(TypeInfo) identify(T)(T object) @trusted nothrow @nogc
    if (is(T : Object) || is(T : const Object) || is(T : immutable Object)) {

    if (object is null) {
        return typeid(null);
    }

    TypeAware p = cast(TypeAware) object;

    if (p !is null) {
        return p.type;
    }

    return object.classinfo;
}

/**
ditto
**/
const(TypeInfo) identify(T)(auto ref T component) nothrow @nogc @safe
    if (!(is(T : Object) || is(T : const Object) || is(T : immutable Object))) {
    import std.stdio;

    return typeid(component);
}

/**
ditto
**/
T identify(T : TypeInfo)(auto ref T typeinfo) nothrow @nogc @safe {
    import std.stdio;

    return typeinfo;
}

/**
ditto
**/
T identify(T : const TypeInfo)(auto ref T typeinfo) nothrow @nogc @safe {
    import std.stdio;

    return typeinfo;
}

/**
ditto
**/
T identify(T : immutable TypeInfo)(auto ref T typeinfo) nothrow @nogc @safe {
    import std.stdio;

    return typeinfo;
}

/**
Identify the original type of converted component.

Identify the original type of converted component.
The object will be downcasted to OriginalTypeAware
interface and if it succeeded original type will be
returned. For non-object components typeid(void)
will be returned as no OriginalTypeAware they could implement.

Params:
    object = converted component for which original type would need to be identified.
Returns:
    TypeInfo of original type from which current one was converted.
**/
const(TypeInfo) original(T)(T object) @trusted nothrow @nogc pure
    if (is(T : Object) || is(T : const Object) || is(T : immutable Object)) {

    if (object is null) {
        return typeid(void);
    }

    OriginalTypeAware p = cast(OriginalTypeAware) object;

    if (p !is null) {
        return p.original;
    }

    return object.classinfo;
}

/**
ditto
**/
TypeInfo original(T)(auto ref T component) nothrow @nogc @safe
    if (!(is(T : Object) || is(T : const Object) || is(T : immutable Object))) {
    import std.stdio;

    return typeid(void);
}

/**
ditto
**/
TypeInfo original(T : TypeInfo)(auto ref T typeinfo) nothrow @nogc @safe {
    import std.stdio;

    return typeid(void);
}

/**
ditto
**/
const(TypeInfo) original(T : const TypeInfo)(auto ref T typeinfo) nothrow @nogc @safe {
    import std.stdio;

    return typeid(void);
}

/**
ditto
**/
immutable(TypeInfo) original(T : immutable TypeInfo)(auto ref T typeinfo) nothrow @nogc @safe {
    import std.stdio;

    return typeid(void);
}

/**
ditto
**/
const(TypeInfo) original(T)(T object, const TypeInfo from) @trusted nothrow @nogc pure {
    auto result = object.original;

    if (result is typeid(void)) {
        return from;
    }

    return result;
}

/**
Identify the convertor used to convert component.

Identify the convertor used to convert component.
The object will be downcasted to ConvertorAware
interface and if it succeeded convertor used to
convert component will be returned. For non-object
components null will be returned as no convertor
can be extracted from them.

Params:
    object = converted component for which used convertor would need to be identified.
Returns:
    Convertor used to convert to contained component.
**/
const(Convertor) convertorOf(T)(T object) @trusted nothrow @nogc pure
    if (is(T : Object) || is(T : const Object) || is(T : immutable Object)) {

    if (object !is null) {
        ConvertorAware p = cast(ConvertorAware) object;

        if (p !is null) {
            return p.convertor;
        }
    }

    return null;
}

/**
ditto
**/
Convertor convertorOf(T)(auto ref T component) nothrow @nogc @safe
    if (!(is(T : Object) || is(T : const Object) || is(T : immutable Object))) {
    import std.stdio;

    return null;
}

/**
ditto
**/
Convertor convertorOf(T : Convertor)(auto ref T convertor) nothrow @nogc @safe {
    import std.stdio;

    return convertor;
}

/**
ditto
**/
const(Convertor) convertorOf(T : const Convertor)(auto ref T convertor) nothrow @nogc @safe {
    import std.stdio;

    return convertor;
}

/**
ditto
**/
immutable(Convertor) convertorOf(T : immutable Convertor)(auto ref T convertor) nothrow @nogc @safe {
    import std.stdio;

    return convertor;
}

/**
Identify the allocator used to convert component.

Identify the allocator used to convert component.
The object will be downcasted to AllocatorAware
interface and if it succeeded convertor used to
convert component will be returned. For non-object
components empty allocator will be returned as no convertor
can be extracted from them.

Params:
    object = converted component for which used allocator would need to be identified.
Returns:
    RCIAllocator used in conversion process.
**/
RCIAllocator allocatorOf(T)(T object) @trusted nothrow @nogc pure
    if (is(T : Object) || is(T : const Object) || is(T : immutable Object)) {

    if (object !is null) {
        AllocatorAware p = cast(AllocatorAware) object;

        if (p !is null) {
            return p.allocator;
        }
    }

    return RCIAllocator(null);
}

/**
ditto
**/
RCIAllocator allocatorOf(T)(auto ref T component) nothrow @nogc @safe
    if (!(is(T : Object) || is(T : const Object) || is(T : immutable Object))) {
    import std.stdio;

    return RCIAllocator(null);
}

/**
ditto
**/
RCIAllocator allocatorOf(T : RCIAllocator)(auto ref T allocator) nothrow @nogc @safe {
    import std.stdio;

    return allocator;
}

/**
ditto
**/
const(RCIAllocator) allocatorOf(T : const Convertor)(auto ref T allocator) nothrow @nogc @safe {
    import std.stdio;

    return allocator;
}

/**
ditto
**/
immutable(RCIAllocator) allocatorOf(T : immutable Convertor)(auto ref T allocator) nothrow @nogc @safe {
    import std.stdio;

    return allocator;
}

/**
ditto
**/
RCIAllocator allocatorOf(T)(T object, RCIAllocator allocator) @trusted nothrow @nogc pure {
    auto result = object.allocatorOf;

    if (result.isNull) {
        return allocator;
    }

    return result;
}